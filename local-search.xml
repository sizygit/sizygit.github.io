<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>simulinkNote</title>
    <link href="/2024/03/18/simulinkNote/"/>
    <url>/2024/03/18/simulinkNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Simulink常用工具"><a href="#Simulink常用工具" class="headerlink" title="Simulink常用工具"></a>Simulink常用工具</h1><h2 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​Stateflow 图是有限状态机的图形表示，由状态、转移和数据组成。您可以创建 Stateflow 图来定义 MATLAB 算法或 Simulink模型如何响应外部输入信号、事件和基于时间的条件。Stateflow 编辑器是一个图形环境，用于设计状态转移图、流程图、状态转移表和真值表。在打开 Stateflow 编辑器之前，需要先确定最能满足您需求的图执行模式。</p><ul><li><p>要建立周期性或连续时间 Simulink 算法的条件、基于事件和基于时间的逻辑模型，直接在simulink中导入<code>chart</code>模块。</p></li><li><p>要为 MATLAB 应用程序设计可重用的状态机和时序逻辑，请使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/edit.html"><code>edit</code></a> 函数创建可作为 MATLAB 对象执行的独立 Stateflow 图。在 MATLAB 命令提示符处，输入：</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">edit sfDemo.sfx  <span class="hljs-comment">% create chart for execution as a MATLAB object</span><br></code></pre></td></tr></table></figure></li></ul><p>​Stateflow编辑器主要包括图画布、对象选项板和符号图窗；图画布是表示Stateflow的绘图区域，左侧的对象选项板是可添加图形元素的工具（空格键可自动自适应大小），右侧的符号图窗则是用来添加或编辑数据、时间和消息的工具，如下图：</p><p><img src="/2024/03/18/simulinkNote/stateflow1.png"></p><p>​最简单的<code>State</code>模块可用左键拖出，可定义状态名称与状态动作；同时可以在不同的状态间绘制状态转移线，在线上可添加不同的事件名称、转移条件及动作。<code>Juction</code>通常是作为分支逻辑和条件判断的选择点；<code>Default transition</code>模块则是默认选择子状态的转移线。通常运行需定义图中所有符号的作用域（如输入数据、输出数据或常量数据），通过点击左侧对应的type图表进行修改。</p><h3 id="状态与转移"><a href="#状态与转移" class="headerlink" title="状态与转移"></a>状态与转移</h3><p>​Stateflow的状态名称由字母数字和下划线字符组合而成，相关规范及保留关键字细节可参考<a href="https://ww2.mathworks.cn/help/stateflow/ug/rules-for-naming-stateflow-objects.html">Stateflow命名规范</a>。状态内需要定义不同的状态动作，状态动作主要包括entry(en)、during(du)、exit(ex)、on、bind几种类型，通常使用**typename :**后接相应的动作语句，如果直接在状态名称后添加语句，图会将这些语句解释为组合的 <code>entry</code> 和 <code>during</code> 动作。</p><ul><li><strong>entry</strong>：状态起始被激活时执行，通常用于执行初始化或准备工作。</li><li><strong>during</strong>：状态被起始激活后(上一周期时间步执行过<code>entry</code>)且没有到另一个状态的有效转移时执行。</li><li><strong>exit</strong>：状态被激活且发生转出状态的转移时执行。</li><li><strong>on</strong>：状态被激活且接收到指定的事件或消息时执行，可参考<a href="https://ww2.mathworks.cn/help/stateflow/ug/how-events-work-in-stateflow-charts.html">通过广播事件同步模型组件</a>和<a href="https://ww2.mathworks.cn/help/stateflow/ug/message-syntax-in-charts.html">通过发送消息与 Stateflow 图通信</a>。</li><li><strong>bind</strong>：用于将变量或参数绑定到不同的作用域，以实现数据共享或更改。</li></ul><p>​状态的转移与计算可参考<a href="https://ww2.mathworks.cn/help/stateflow/ug/chart-initialization-and-entry-actions.html">进入图或状态</a>，<a href="https://ww2.mathworks.cn/help/stateflow/ug/evaluate-transitions.html">计算转移</a>。<strong>默认转移</strong>是一种没有源的转移。在不包含任何状态的 Stateflow 图中，默认转移标记流程图（子图）的开始，图（子图）仅在进入状态时计算状态内的默认转移路径，而不是在图每次唤醒时计算。<strong>外部转移</strong>是一种退出源状态的转移，需要使用使用状态之间的转移箭头，Stateflow 图将标记待计算的外部转移作为执行状态的<strong>第一步</strong>，没有有效的外部转移才会执行该状态的<code>during</code>。<strong>内部转移</strong>是一种不退出源状态的转移，（参阅<a href="https://ww2.mathworks.cn/help/stateflow/ug/inner-transitions.html">Control Chart Execution by Using Inner Transitions</a>），当前状态执行<code>during</code>后会标记待计算的内部转移。通常的转移标签类型为</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">(Event/<span class="hljs-keyword">Message</span> <span class="hljs-keyword">name</span>)[Condition]<span class="hljs-comment">&#123;ConditionAction&#125;</span> <br></code></pre></td></tr></table></figure><p><code>Condition</code> 是布尔表达式，用于确定是否发生转移。如果不指定条件，转移将在源状态被激活后的<strong>下一个时间步</strong>发生。在转移标签语法中，若转移动作以<strong>正斜杠 (<code>/</code>) 开头</strong>，并括在花括号前 (<code>/&#123;action&#125;</code>)，仅在转移路径确定为有效后，转移动作才会执行（在转移含有条件与动作时下需要避免计算回溯）。 <code>ConditionAction</code> 是在判断转移的条件为 true 时执行的指令。条件动作发生在条件后，但在任何 <code>exit</code> 或 <code>entry</code> 状态动作之前。Stateflow中含有内置的<strong>隐式事件</strong>，可参考<a href="https://ww2.mathworks.cn/help/stateflow/ug/using-implicit-events.html">通过使用隐式事件控制图行为</a>。</p><h3 id="子系统与子图"><a href="#子系统与子图" class="headerlink" title="子系统与子图"></a>子系统与子图</h3><p>​类似子系统，也可在Stateflow中创建子图和子状态，创建子状态，请点击状态工具，将新状态拖到要作为其父状态的状态中。当父状态被激活时，子状态之一也被激活。当父状态变为非激活时，所有子状态都变为非激活。在一个时间步长内，<strong>初始化</strong>时父状态被激活时，会优先执行entry（初始化），若无<a href="https://ww2.mathworks.cn/help/stateflow/ug/recording-state-activity-with-history-junctions.html">历史节点</a>则通过<strong>默认转移</strong>到子状态执行<code>entry</code>；初始化后若图<strong>再次被唤醒</strong>，首先判断父状态的的外部转移，无有效转移执行父状态的<code>during</code>，之后在被激活的子状态中执行转移或<code>during</code>等。</p><p>​一个包含子系统的图初始化如下：</p><img src="/2024/03/18/simulinkNote/包含子系统的初始化.png" style="zoom:85%;"><p>​一个包含子系统的执行流程如下：</p><p><img src="/2024/03/18/simulinkNote/%E5%8C%85%E5%90%AB%E5%AD%90%E7%B3%BB%E7%BB%9F.png"></p><p>​如果您需要 Stateflow 图记住并返回到以前激活的子状态，而不考虑默认转移，则应使用<strong>历史结点</strong>。将历史结点置于某状态之内会覆盖指向互斥  (OR) 子状态的默认转移。在将历史结点置于某状态内后，在执行 entry 动作时，您的 Stateflow  图会记住并进入先前激活的子状态。历史结点只会应用到层次结构中其所在的层级。</p><h3 id="使用状态分解设置子系统的互斥与并行"><a href="#使用状态分解设置子系统的互斥与并行" class="headerlink" title="使用状态分解设置子系统的互斥与并行"></a>使用状态分解设置子系统的互斥与并行</h3><p>​图或状态的分解类型指定图或状态包含互斥状态还是并行状态：<strong>互斥状态</strong>表示互斥的工作模式，同一层级上不能有两个互斥状态同时被激活或执行。Stateflow 图用实线矩形表示每个互斥状态。<strong>并行状态</strong>表示独立的工作模式，虽然并行状态会依次执行，但可以有两个或多个并行状态同时处于激活状态，Stateflow 图用虚线矩形表示每个并行状态，其中的数字表示其执行顺序。</p><p>​子状态的外观指示其父状态的分解，同时需显式指定并行顺序（参考<a href="https://ww2.mathworks.cn/help/stateflow/ug/execution-order-for-parallel-states.html">并行状态的执行顺序</a>），如下：</p><p><img src="/2024/03/18/simulinkNote/%E5%B9%B6%E8%A1%8C.png"></p><h3 id="通过广播事件同步并行状态"><a href="#通过广播事件同步并行状态" class="headerlink" title="通过广播事件同步并行状态"></a>通过广播事件同步并行状态</h3><p>​<strong>局部事件</strong>允许一个状态触发同一个 Stateflow图中另一个状态的转移或动作，从而使您能够<strong>协调并行状态</strong>。要将事件从一个状态广播到另一个状态，请使用 <code>send</code> 运算符以及事件的名称和激活状态的名称：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">send(eventName,stateName)<br></code></pre></td></tr></table></figure><p>当您广播事件时，该事件将在接收状态以及该状态层次结构中的任何子状态中均生效，注意广播的该事件通常只作用于本次时间步内。局部事件为固定事件类型，无需设置。</p><p>​Stateflow还可以与图外部的事件进行交互，如<a href="https://ww2.mathworks.cn/help/stateflow/ug/using-input-events-to-activate-a-stateflow-chart.html">接受输入事件</a>或<a href="https://ww2.mathworks.cn/help/stateflow/ug/using-output-events-to-activate-a-simulink-block.html">输出事件</a>。</p><p>​<strong>输出事件</strong>直接使用<code>send(eventName)</code>来广播，每个输出事件对应一个输出端口，在Modeling-Symbols Pane新建对应事件并将其设置为Output Event，右键打开事件的Inspector可配置输出事件<code>Trigger</code>属性，可设置为Either Edge（边沿触发）或Function call（函数调用）两种，均可用来传递或激活其他simulink模块，例如<a href="https://ww2.mathworks.cn/help/simulink/ug/triggered-subsystems.html">触发子系统</a>或<a href="https://ww2.mathworks.cn/help/simulink/ug/using-function-call-subsystems.html">函数调用子系统</a>。</p><ul><li>Either Edge：会输出0-1的上升下降沿，触发子系统可以读取上升或者下降沿，或者Either Edge，可作为常量显示。对于每个时间步，图<strong>仅调度</strong>边沿触发输出事件的<strong>一个广播</strong>，若多次广播一个事件时，图只会广播一次该事件，在后续时间步中继续广播该事件（信号0-1的限制）。</li></ul><p><img src="/2024/03/18/simulinkNote/%E8%BE%93%E5%87%BA.png"></p><ul><li>Function call：输出函数调用事件会激活 Simulink 模块，使其在仿真的当前时间步内执行。这种类型的输出事件只对可以使用函数调用触发的模块有效，可参阅<a href="https://ww2.mathworks.cn/help/simulink/ug/using-function-call-subsystems.html">使用函数调用子系统</a> (Simulink)。当单个时间步中存在某一函数调用输出事件的多个广播时，图会在该时间步内<strong>调度所有广播</strong>（<strong>与边沿触发不同</strong>）。函数调用子系统的执行与图的执行<strong>交叉进行</strong>，因此<strong>函数调用子系统的输出可立即在图中使用</strong>。基于此特性，可以设计一个循环调度器，从而能在一个时间步多次执行函数调用子系统，如下：</li></ul><p><img src="/2024/03/18/simulinkNote/%E5%BE%AA%E7%8E%AF%E8%B0%83%E5%BA%A6%E5%99%A8.png"></p><p>​使用<strong>输入事件</strong>激活Stateflow图，只需要在Symbols中添加一个Input Event，可以将触发器属性设置为上升、下降沿或函数调用。在任意给定时间步，按其端口号升序检查输入事件。对于边沿触发输入事件，同一时间步内可能会出现多个边沿，这会在该时间步内将 Stateflow  图唤醒多次。在这种情况下，事件按其端口号的升序顺序唤醒 Stateflow 图。</p><h3 id="使用状态激活数据监视图活动"><a href="#使用状态激活数据监视图活动" class="headerlink" title="使用状态激活数据监视图活动"></a>使用状态激活数据监视图活动</h3><p>​Stateflow图中的状态在运行时可以实时显示当前状态，为了更为直观分析状态的转移历史，我们可以通过Data Inspector来记录状态值。Data Inspector可以记录局部数据、输出数据的数值，还可以用来记录状态的activity，如下：</p><p><img src="/2024/03/18/simulinkNote/%E7%9B%91%E8%A7%86%E7%8A%B6%E6%80%81.png"></p><p>​如果 Stateflow 图包含与图层次结构相关的数据，则可以使用活动状态数据( <strong>Active State Data</strong>)来简化设计，Stateflow通过输出端口将状态活动报告给Simulink或用作图表中的本地数据。激活状态数据有三种类型：</p><table><thead><tr><th>Activity Type</th><th>Active State Data Type</th></tr></thead><tbody><tr><td>Self activity</td><td>Boolean</td></tr><tr><td>Child activity</td><td>[Enumeration]( <a href="https://ww2.mathworks.cn/help/stateflow/ug/about-active-state-data.html#bt5zn9j-1">Define State Activity Enumeration Type</a>.)</td></tr><tr><td>Leaf state activity</td><td>Enumeration</td></tr></tbody></table><p>​您可以为状态流图、状态、状态转换表或原子子图启用活动状态数据，下表列出了每种状态流对象支持的活动类型。</p><table><thead><tr><th>Stateflow Object</th><th>Self-Activity</th><th>Child Activity</th><th>Leaf State Activity</th></tr></thead><tbody><tr><td>Charts</td><td>Not supported</td><td>Supported</td><td>Supported</td></tr><tr><td>States with exclusive (OR) decomposition</td><td>Supported</td><td>Supported</td><td>Supported</td></tr><tr><td>States with parallel (AND) decomposition</td><td>Supported</td><td>Not supported</td><td>Not supported</td></tr><tr><td>Atomic subcharts</td><td>Supported at the container level</td><td>Supported inside the subchart</td><td>Supported inside the subchart</td></tr><tr><td>State transition tables</td><td>Not supported</td><td>Supported</td><td>Supported</td></tr></tbody></table><p><img src="/2024/03/18/simulinkNote/%E6%BF%80%E6%B4%BB%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE.png"></p><p>​输出的枚举类型可在Data Inspector与Scope中直接显示，也可以直接使用<code>double</code>模块强制转换为浮点数，通常会涉及到<a href="https://ww2.mathworks.cn/help/simulink/slref/memory.html">Memory</a>这个模块，用来储存上一时刻的值。Stateflow还提供了操作符<code>in</code>来检查状态是否激活（尽量使用状态的完整名称），用法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">in(state_name) <span class="hljs-comment">%若状态state_name激活返回1，反之为0</span><br></code></pre></td></tr></table></figure><h3 id="使用时序逻辑调度"><a href="#使用时序逻辑调度" class="headerlink" title="使用时序逻辑调度"></a>使用时序逻辑调度</h3><p>​定义 Stateflow 图在仿真时间的行为，可在图的状态和转移动作中使用时序逻辑运算符。时间逻辑运算符是内置函数，告诉状态保持活动状态或布尔条件保持为真的时间长度。以下是最常见的绝对时间时序逻辑运算符：</p><ul><li><a href="https://ww2.mathworks.cn/help/stateflow/ref/after.html">after</a> - 如果自包含该运算符的状态或包含该运算符的转移的源状态被激活以来经过的仿真时间达到 <code>n</code> 秒，则 <code>after(n,sec)</code> 返回 <code>true</code>。否则，运算符返回 <code>false</code>。此运算符支持以秒 (<code>sec</code>)、毫秒 (<code>msec</code>) 和微秒 (<code>usec</code>) 计的基于事件的时序逻辑和绝对时间时序逻辑。</li><li><a href="https://ww2.mathworks.cn/help/stateflow/ref/elapsed.html">elapsed</a> - <code>elapsed(sec)</code> 返回自关联状态激活以来经过的仿真时间的秒数，表达式 <code>elapsed(sec)</code> 和 <code>et</code> 等效于 <code>temporalCount(sec)</code>。</li><li><a href>duration</a> - <code>duration(C)</code> 返回自布尔条件 <code>C</code> 变为 <code>true</code> 以来经过的仿真时间的秒数。</li></ul><h2 id="Model-Linearizer"><a href="#Model-Linearizer" class="headerlink" title="Model Linearizer"></a><strong>Model Linearizer</strong></h2><p>​使用 Model Linearizer，您可以分析线性化模型的时域和频域响应。您可以比较多个模型的响应并查看稳定裕度和稳定时间等系统特性。</p><p>参考官网链接:<a href="https://ww2-mathworks-cn.translate.goog/help/slcontrol/ug/linearize-simulink-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型工作点线性化Simulink 模型</a>,   <a href="https://ww2-mathworks-cn.translate.goog/help/slcontrol/ug/analyze-results-using-linear-analysis-tool-response-plots-1.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">使用模型线性化器响应图分析结果使用模型线性化器响应图分析结果</a>  <a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/specify-portion-of-model-to-linearize-in-linear-analysis-tool.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型线性化器中指定要线性化的模型部分</a></p><table><thead><tr><th></th><th>Simulink Control Design Linearization</th></tr></thead><tbody><tr><td>图形用户界面</td><td>是的。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/linearize-simulink-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型工作点线性化 Simulink 模型</a>。</td></tr><tr><td>灵活定义模型的哪一部分进行线性化</td><td>是的。允许您以图形方式或编程方式在 Simulink 模型的任何级别指定线性化 I&#x2F;O 点，而无需修改您的模型。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/linearize-at-trimmed-operating-point.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在修整的工作点进行线性化</a>。</td></tr><tr><td>开环分析</td><td>是的。允许您在不删除模型中的反馈信号的情况下打开反馈回路。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/open-loop-response-of-control-system-for-stability-margin-analysis.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">计算开环响应</a>。</td></tr><tr><td>控制线性模型状态排序</td><td>是的。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/state-order-in-linearized-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">线性化模型中的顺序状态</a>。</td></tr><tr><td>控制单个块的线性化</td><td>是的。允许您为模块和子系统指定自定义线性化行为。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/when-to-specify-individual-block-linearization.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">何时指定单个块线性化</a>。</td></tr><tr><td>线性化诊断</td><td>是的。识别有问题的块并让您检查每个块的线性化值。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/linearization-troubleshooting-overview.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">线性化故障排除概述</a>。</td></tr><tr><td>块检测和减少</td><td>是的。块缩减检测对整体线性化没有贡献的块，从而产生最小实现。</td></tr><tr><td>多速率模型速率转换算法的控制</td><td>是的</td></tr></tbody></table><p>分析点类型：</p><ul><li><strong>Input Perturbation</strong> — Specifies an additive input to a signal.</li><li><strong>Output Measurement</strong> — Takes a measurement at a signal.</li><li><strong>Loop Break</strong> — Specifies a loop opening.</li><li><strong>Open-Loop Input</strong> — Specifies a loop break followed by an input perturbation.</li><li><strong>Open-Loop Output</strong> — Specifies an output measurement followed by a loop break.</li><li><strong>Loop Transfer</strong> — Specifies an output measurement before a loop break followed by an input perturbation.</li><li><strong>Sensitivity</strong> — Specifies an input perturbation followed by an output measurement.</li><li><strong>Complementary Sensitivity</strong> — Specifies an output measurement followed by an input perturbation</li></ul><p>​若想要指定开环分析（屏蔽掉外环反馈）或闭环，可利用Open-Loop Input&#x2F;Output，可以选择以下组合：1.  <strong>Open-Loop Input+Output Measurement</strong> (闭环) 2. <strong>Input Perturbation+Output Measurement</strong>(闭环) 3. **Open-Loop Input+Open-Loop Output **(开环) 4. <strong>Input Perturbation+Open-Loop Output</strong>(开环)</p><p>​对选择的信号插入Input Point &#x2F; Output Point</p><ul><li><p>要指定要线性化的模型部分，首先打开线性化选项卡。为此，在Simulink 窗口的Apps 库中，点击Linearization Manager 。</p></li><li><p>要为信号指定分析点，请点击模型中的信号。然后，在“线性化”选项卡上的“插入分析点”库中，选择分析点的类型。</p></li><li><p>将分析的信号配置为Input Perturbation。将输出信号配置为Open-loop Output。开环输出点是在开环后进行的输出测量，它在不改变模型工作点的情况下消除了反馈信号对线性化的影响。要指定要线性化的模型部分，首先打开线性化选项卡。为此，在 Simulink 窗口的 Apps 库中，点击 Linearization Manager 。</p></li></ul><p>​     Model Linearize进入绘制波特图</p><p>实例：</p><p><img src="/2024/03/18/simulinkNote/image-20230619190121382.png" alt="image-20230619190121382"></p><h2 id="Matlab中的C-MEX函数"><a href="#Matlab中的C-MEX函数" class="headerlink" title="Matlab中的C++MEX函数"></a>Matlab中的C++MEX函数</h2><p>​C++与Matlab的混合使用，matlab调用c++的动态链接库或者使用C++MEX函数调用Matlab等可以参看<a href="https://ww2.mathworks.cn/help/matlab/cpp-language.html?s_tid=CRUX_lftnav">官方链接</a>。MEX函数是可以自动加载，可以像任何 MATLAB 函数一样调用的程序，C++MEX其主要依靠<a href="https://ww2.mathworks.cn/help/matlab/matlab-data-array.html">MATLAB Data API</a>与<a href="https://ww2.mathworks.cn/help/matlab/cpp-engine-api.html">MATLAB C++ Engine API</a>，前者提供了C++接口来处理MATLAB数据，后者提供了C++11及串联Matlab的诸多功能处理(如使用<a href="https://ww2.mathworks.cn/help/matlab/apiref/matlab.engine.matlabengine_cpp.html">matlab::engine::MATLABEngine</a>调用matlab函数)。</p><p>​C++MEX函数必须继承基类 <a href="https://ww2.mathworks.cn/help/matlab/apiref/matlab.mex.function.html"><code>matlab::mex::Function</code></a>且名称为 <code>MexFunction</code>的子类，并重写函数调用运算符 <code>operator()</code>；MEX 函数的输入和输出作为<a href="https://ww2.mathworks.cn/help/matlab/apiref/matlab.mex.argumentlist.html"><code>matlab::mex::ArgumentList</code></a> 中的元素进行传递，如下是一个简单的示意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* MyMEXFunction annotation</span><br><span class="hljs-comment"> * c = MyMEXFunction(a,b);</span><br><span class="hljs-comment"> * Adds offset argument a to each element of double array b and</span><br><span class="hljs-comment"> * returns the modified array c.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mex.hpp&quot;</span>   <span class="hljs-comment">// Include this file for the C++ MEX API.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mexAdapter.hpp&quot;</span>  <span class="hljs-comment">// Utility needed for C++ MEX function operator</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> matlab::data;   <br><span class="hljs-keyword">using</span> matlab::mex::ArgumentList; <span class="hljs-comment">// input output data type</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MexFunction</span> : <span class="hljs-keyword">public</span> matlab::mex::Function &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ArgumentList outputs, ArgumentList inputs)</span> </span>&#123;<br>        <span class="hljs-built_in">checkArguments</span>(outputs, inputs);<br>        <span class="hljs-type">const</span> <span class="hljs-type">double</span> offSet = inputs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        TypedArray&lt;<span class="hljs-type">double</span>&gt; doubleArray = std::<span class="hljs-built_in">move</span>(inputs[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : doubleArray) &#123;<br>            elem += offSet;<br>        &#125;<br>        outputs[<span class="hljs-number">0</span>] = doubleArray;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkArguments</span><span class="hljs-params">(ArgumentList outputs, ArgumentList inputs)</span> </span>&#123;<br>        <span class="hljs-comment">// Get pointer to engine</span><br>        std::shared_ptr&lt;matlab::engine::MATLABEngine&gt; matlabPtr = <span class="hljs-built_in">getEngine</span>();<br>        <span class="hljs-comment">// Get array factory: matlab::data::ArrayFactory Create arrays</span><br>        ArrayFactory factory;<br>        <span class="hljs-comment">// Check offset argument: First input must be scalar double</span><br>        <span class="hljs-keyword">if</span> (inputs[<span class="hljs-number">0</span>].<span class="hljs-built_in">getType</span>() != ArrayType::DOUBLE || inputs[<span class="hljs-number">0</span>].<span class="hljs-built_in">getNumberOfElements</span>() != <span class="hljs-number">1</span> || inputs[<span class="hljs-number">1</span>].<span class="hljs-built_in">getType</span>() != ArrayType::DOUBLE)<br>        &#123;<br>            matlabPtr-&gt;<span class="hljs-built_in">feval</span>(<span class="hljs-string">u&quot;error&quot;</span>,<span class="hljs-number">0</span>,<br>                std::<span class="hljs-built_in">vector</span>&lt;Array&gt;(&#123; factory.<span class="hljs-built_in">createScalar</span>(<span class="hljs-string">&quot;Input must be scalar double&quot;</span>) &#125;)); <span class="hljs-comment">// Call the error() using feval()</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​然后使用 <code>mex</code> 命令编译 .cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mex -setup C++  <span class="hljs-comment"># MEX选择c++的编译器</span><br>mex demoMEX.cpp <span class="hljs-comment"># 编译cpp文件生成二进制文件，Windows下为 .mexw64</span><br></code></pre></td></tr></table></figure><p>参考链接<a href="https://ww2.mathworks.cn/help/matlab/matlab_external/c-mex-functions.html">C++ MEX 函数</a>，<a href="https://zhuanlan.zhihu.com/p/511253062">知乎S-function使用</a>，<a href="https://blog.smileland.me/2020/02/12/%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%86%99%E7%AE%80%E5%8D%95S-Function/">2020-02-12-使用C语言写简单S-Function</a></p><h2 id="Simulink中的S-function"><a href="#Simulink中的S-function" class="headerlink" title="Simulink中的S-function"></a>Simulink中的S-function</h2><p>​S-Function属于simulink中的用户自定义模块，是用 MATLAB、C、C++ 或 Fortran  编写的 Simulink 模块的计算机语言描述。使用 mex 实用程序编译为 MEX 文件。S-Function 遵循一般形式，可以适应连续、离散和混合系统。通过遵循一组简单的规则，您可以在 S-Function 中实现算法，并使用  S-Function 模块将其添加到 Simulink 模型。在编写 S-Function 并将其名称放入 S-Function 模块后，您可以使用封装来自定义用户界面（请参阅<a href="https://ww2.mathworks.cn/help/simulink/block-masks.html">Author Block Masks</a>）。</p><p>​S-Function 定义模块在仿真的不同部分（例如初始化、更新、求导、输出和终止）的行为。Level-2 MATLAB S-function是新版simulink引入的升级版，提供了更多的功能与方法。二者均可以在对应模块窗口定义传递参数，各参数以逗号分割。</p><p>​level-1S-Function的通常形式为<code>[sys,x0,str,ts]=f(t,x,u,flag,p1,p2,...)</code>，式中系统根据<code>flag</code>调用不同方法，对应关系如下：</p><table><thead><tr><th>Level-1 Flag</th><th>Level-2 Callback Method</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td><code>setup</code></td><td>定义基本 S-Function 块特征，包括采样时间、连续和离散状态的初始条件以及尺寸数组</td></tr><tr><td>1</td><td><code>mdlDerivatives</code></td><td>计算连续状态变量的导数</td></tr><tr><td>2</td><td><code>mdlUpdate</code></td><td>更新离散状态、采样时间和主要时间步要求</td></tr><tr><td>3</td><td><code>mdlOutputs</code></td><td>计算输出</td></tr><tr><td>4</td><td><code>mdlOutputs</code> 方法更新运行时对象的  <code>NextTimeHit</code> 属性</td><td>以绝对时间计算下一次hit的时间。仅当您在<code>setup</code>方法中指定可变离散时间采样时间时，才使用此例程。</td></tr><tr><td>9</td><td><code>mdlTerminate</code></td><td>执行任何必要的模拟结束任务</td></tr></tbody></table><p>在matlab官方文档中给出了sfundsc2.m转换为sfundsc2_level2.m的代码，可在下表对比：</p><table><thead><tr><th>Code in sfundsc2.m</th><th>Code in Level-2 MATLAB file (sfundsc2_level2.m)</th></tr></thead><tbody><tr><td><code>function [sys,x0,str,ts]= ...  sfundsc2(t,x,u,flag)</code></td><td><code>function sfundsc2(block)  setup(block);</code><br>语法发生更改以接受一个输入参数<a href="https://ww2.mathworks.cn/help/simulink/slref/simulink.msfcnruntimeblock.html">block</a>，其是 Level-2 MATLAB S-Function 块的<strong>运行时间对象</strong>。 Level-2 MATLAB S-Function 的主体包含一行调用本地<code>setup</code>函数。</td></tr><tr><td><code>switch flag, case 0, [sys,x0,str,ts] = ...   mdlInitializeSizes;</code></td><td><code>function setup(block)</code><br> 标志位为0 调用<code>setup</code>方法，level-2不使用switch语句，本地<code>setup</code>函数会注册在模拟过程中直接调用回调方法。</td></tr><tr><td><code>case 2,   sys = mdlUpdate(t,x,u); case 3,   sys = mdlOutputs(t,x,u);</code></td><td><code>block.RegBlockMethod(&#39;Outputs&#39; ,@Output); block.RegBlockMethod(&#39;Update&#39;  ,@Update);</code> <br><code>setup</code>函数注册了两个局部函数，分别与标志值2和3关联。</td></tr><tr><td><code>sizes = simsizes; sizes.NumContStates  = 0; sizes.NumDiscStates  = 1; sizes.NumOutputs     = 1; sizes.NumInputs      = 1; sizes.DirFeedthrough = 0; sizes.NumSampleTimes = 1; sys = simsizes(sizes); x0  = 0; str = []; ts  = [.1 0];</code></td><td><code>setup</code>函数还初始化了MATLAB第2级s函数的属性:<br><code>block.NumInputPorts  = 1; block.NumOutputPorts = 1; block.InputPort(1).Dimensions        = 1; block.InputPort(1).DirectFeedthrough = false; block.OutputPort(1).Dimensions       = 1; block.NumDialogPrms     = 0; block.SampleTimes = [0.1 0];</code>由于此 S-Function 具有离散状态，因此 <code>setup</code> 方法会注册 <code>PostPropagationSetup</code> 回调方法来初始化 <code>DWork</code> 向量，并注册 <code>InitializeConditions</code> 回调方法来设置初始状态值。<code>block.RegBlockMethod(&#39;PostPropagationSetup&#39;,... @DoPostPropSetup); block.RegBlockMethod(&#39;InitializeConditions&#39;, ... @InitConditions);</code></td></tr><tr><td><code>sizes.NumDiscStates  = 1;</code></td><td><code>PostPropagationSetup</code>方法初始化存储单个离散状态的<code>DWork</code>向量。<br><code>function DoPostPropSetup(block)   %% Setup Dwork  block.NumDworks = 1;  block.Dwork(1).Name = &#39;x0&#39;;   block.Dwork(1).Dimensions      = 1;  block.Dwork(1).DatatypeID      = 0;  block.Dwork(1).Complexity      = &#39;Real&#39;;  block.Dwork(1).UsedAsDiscState = true; </code></td></tr><tr><td><code>x0  = 0;</code></td><td><code>PostPropagationSetup</code>方法初始化存储单个离散状态的<code>DWork</code>向量。<br><code>function InitConditions(block) %% Initialize Dwork  block.Dwork(1).Data = 0 </code></td></tr><tr><td><code>function sys = ...   mdlUpdate(t,x,u) sys = u;     </code></td><td><code>Update</code>方法计算离散状态的下一个值。<br><code>function Update(block) block.Dwork(1).Data = block.InputPort(1).Data; </code></td></tr><tr><td><code>function sys = ...   mdlOutputs(t,x,u) sys = x;</code></td><td><code>Outputs</code> 方法计算输出。<br><code>function Outputs(block) block.OutputPort(1).Data = block.Dwork(1).Data;</code></td></tr></tbody></table><p>​A Level-2 MATLAB S-function必须包括<code>setup</code>与<code>Outputs</code>两个方法，其余方法及对应的C MEX函数可参考<a href="https://ww2.mathworks.cn/help/simulink/sfg/writing-level-2-matlab-s-functions.html">writing-level-2-matlab-s-functions</a>，官方提供了一个MATLAB S-function模板文件<a href="edit('msfuntmpl_basic.m')">msfuntmpl_basic.m</a>，用来编写自己的程序(也可以使用sfundemos命令来查看内置的所有模板)。<a href="https://ww2.mathworks.cn/help/simulink/sfg/dwork-matlab.html#brd2qpw">DWork</a>向量是 S-Function 要求 Simulink 引擎分配给模型中 S-Function 的每个实例的内存块，通常离散变量需使用它，其需在<code>PostPropagationSetup</code>方法中初始化向量维度与属性，在<code>Start</code> 或 <code>InitializeConditions</code> 方法中设定初值，且可在其余方法中调用。<a href="https://ww2.mathworks.cn/help/simulink/sfg/s-function-concepts.html">S-Function Concepts</a>中介绍了直接馈通对代数环的影响，及采样时间偏移与可变数组的概念。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msfcn_unit_delay</span><span class="hljs-params">(block)</span></span><br><span class="hljs-comment">% Level-2 MATLAB file S-Function for unit delay demo.</span><br>  setup(block);<br><span class="hljs-comment">%endfunction</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setup</span><span class="hljs-params">(block)</span></span><br>  block.NumDialogPrms  = <span class="hljs-number">1</span>; <span class="hljs-comment">%对话框参数个数</span><br>  block.NumInputPorts  = <span class="hljs-number">1</span>;<br>  block.NumOutputPorts = <span class="hljs-number">1</span>; <span class="hljs-comment">%定义输入输出端口</span><br><br>  block.SetPreCompInpPortInfoToDynamic;<br>  block.SetPreCompOutPortInfoToDynamic;<span class="hljs-comment">%输入端口和输出端口从模型继承编译属性</span><br>  block.InputPort(<span class="hljs-number">1</span>).Dimensions        = <span class="hljs-number">1</span>;<br>  block.InputPort(<span class="hljs-number">1</span>).DirectFeedthrough = <span class="hljs-built_in">false</span>; <span class="hljs-comment">%无直接馈通</span><br>  block.OutputPort(<span class="hljs-number">1</span>).Dimensions       = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">%block.NumContStates = 1;% Set up the continuous states.</span><br>  <br>  block.SampleTimes = [<span class="hljs-number">0.1</span> <span class="hljs-number">0</span>];<span class="hljs-comment">%[-1 0]表示采用继承的采样时间 [0 0]连续采样时间</span><br>  <span class="hljs-comment">%% Set the block simStateCompliance to default (i.e., same as a built-in block)</span><br>  block.SimStateCompliance = <span class="hljs-string">&#x27;DefaultSimState&#x27;</span>;<br>  <span class="hljs-comment">%% 注册回调方法</span><br>  block.RegBlockMethod(<span class="hljs-string">&#x27;PostPropagationSetup&#x27;</span>, @DoPostPropSetup);<br>  block.RegBlockMethod(<span class="hljs-string">&#x27;InitializeConditions&#x27;</span>, @InitConditions);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Outputs&#x27;</span>, @Output);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Update&#x27;</span>,  @Update);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Derivatives&#x27;</span>, @Derivatives)<br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoPostPropSetup</span><span class="hljs-params">(block)</span></span><br>  <span class="hljs-comment">%% 初始化离散状态变量，不能在setup方法中初始化离散变量</span><br>  block.NumDworks = <span class="hljs-number">1</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).Name = <span class="hljs-string">&#x27;x0&#x27;</span>; <br>  block.Dwork(<span class="hljs-number">1</span>).Dimensions      = <span class="hljs-number">1</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).DatatypeID      = <span class="hljs-number">0</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).Complexity      = <span class="hljs-string">&#x27;Real&#x27;</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).UsedAsDiscState = <span class="hljs-built_in">true</span>;<br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InitConditions</span><span class="hljs-params">(block)</span>%初始化连续或离散<span class="hljs-title">DWork</span>变量的值</span><br>  block.Dwork(<span class="hljs-number">1</span>).Data = block.DialogPrm(<span class="hljs-number">1</span>).Data;<br>  <span class="hljs-comment">% block.ContStates.Data(1) = 1.0; %ContStates方法初始化连续变量</span><br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-comment">%% 连续变量必须声明Derivatives方法来设置导数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Derivatives</span><span class="hljs-params">(block)</span></span><br>block.Derivatives.Data(<span class="hljs-number">1</span>) = block.InputPort(<span class="hljs-number">1</span>).Data;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Output</span><span class="hljs-params">(block)</span></span><br>  block.OutputPort(<span class="hljs-number">1</span>).Data = block.Dwork(<span class="hljs-number">1</span>).Data;<br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Update</span><span class="hljs-params">(block)</span></span><br>  block.Dwork(<span class="hljs-number">1</span>).Data = block.InputPort(<span class="hljs-number">1</span>).Data;<br><span class="hljs-comment">%endfunction</span><br></code></pre></td></tr></table></figure><p>如下给出一个生成$\ddot{x} &#x3D; -25\dot{x}+133u(t)+d(t)$的Level-2 S-Function的示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chap2_7plantL2</span><span class="hljs-params">(block)</span></span><br><span class="hljs-comment">% Level-2 MATLAB file S-Function for \ddot&#123;x&#125; = -25\dot&#123;x&#125;+133u(t)+d(t)。</span><br>  setup(block);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setup</span><span class="hljs-params">(block)</span></span><br>  block.NumDialogPrms  = <span class="hljs-number">0</span>; <span class="hljs-comment">%对话框参数个数</span><br>  block.NumInputPorts  = <span class="hljs-number">1</span>;<br>  block.NumOutputPorts = <span class="hljs-number">1</span>; <span class="hljs-comment">%定义输入输出端口</span><br>  block.SetPreCompInpPortInfoToDynamic;<br>  block.SetPreCompOutPortInfoToDynamic;<span class="hljs-comment">%输入端口和输出端口从模型继承编译属性</span><br>  block.InputPort(<span class="hljs-number">1</span>).Dimensions        = <span class="hljs-number">1</span>;<br>  block.InputPort(<span class="hljs-number">1</span>).DirectFeedthrough = <span class="hljs-built_in">false</span>; <span class="hljs-comment">%无直接馈通</span><br>  block.OutputPort(<span class="hljs-number">1</span>).Dimensions       = <span class="hljs-number">2</span>;<br>  block.NumContStates = <span class="hljs-number">2</span>;<span class="hljs-comment">% Set up the continuous states.</span><br>  block.SampleTimes = [<span class="hljs-number">-1</span> <span class="hljs-number">0</span>];<span class="hljs-comment">%[-1 0]表示采用继承的采样时间</span><br>  <span class="hljs-comment">%% Set the block simStateCompliance to default (i.e., same as a built-in block)</span><br>  block.SimStateCompliance = <span class="hljs-string">&#x27;DefaultSimState&#x27;</span>;<br>  <span class="hljs-comment">%% 注册回调方法</span><br>  block.RegBlockMethod(<span class="hljs-string">&#x27;InitializeConditions&#x27;</span>, @InitConditions);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Outputs&#x27;</span>, @Output);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Derivatives&#x27;</span>, @Derivatives)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InitConditions</span><span class="hljs-params">(block)</span>%初始化连续或离散<span class="hljs-title">DWork</span>变量的值</span><br>    block.ContStates.Data = [<span class="hljs-number">0</span> <span class="hljs-number">0</span>]; <span class="hljs-comment">%方法初始化连续变量</span><br><span class="hljs-comment">%% 连续变量必须声明Derivatives方法来设置导数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Derivatives</span><span class="hljs-params">(block)</span></span><br>    dt = <span class="hljs-number">50</span> * <span class="hljs-built_in">sin</span>(block.CurrentTime);      <br>block.Derivatives.Data(<span class="hljs-number">1</span>) = block.ContStates.Data(<span class="hljs-number">2</span>);<br>    block.Derivatives.Data(<span class="hljs-number">2</span>) = <span class="hljs-number">-25</span>*block.ContStates.Data(<span class="hljs-number">2</span>)+<span class="hljs-number">133</span>*block.InputPort(<span class="hljs-number">1</span>).Data+dt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Output</span><span class="hljs-params">(block)</span> </span><br>    block.OutputPort(<span class="hljs-number">1</span>).Data(<span class="hljs-number">1</span>)= block.ContStates.Data(<span class="hljs-number">1</span>);<br>    block.OutputPort(<span class="hljs-number">1</span>).Data(<span class="hljs-number">2</span>)= block.ContStates.Data(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="fuzzyControl工具箱"><a href="#fuzzyControl工具箱" class="headerlink" title="fuzzyControl工具箱"></a>fuzzyControl工具箱</h2><h3 id="模糊推理系统GUI编辑器"><a href="#模糊推理系统GUI编辑器" class="headerlink" title="模糊推理系统GUI编辑器"></a>模糊推理系统GUI编辑器</h3><h4 id="GUI界面"><a href="#GUI界面" class="headerlink" title="GUI界面"></a>GUI界面</h4><p>在matlab命令行输入<code>fuzzy</code>即可进入FIS的GUI。</p><p>界面分为菜单条，模块区，模糊逻辑区与当前变量区。</p><blockquote><p>T-S与Mamdani型的模糊逻辑区与输出量框区存在差异</p></blockquote><p>熟悉编辑FIS输入，输出量的名称与维数。</p><p>Mamdani型的模糊逻辑区：</p><p><img src="/2024/03/18/simulinkNote/Mamdani%E6%A8%A1%E7%B3%8A%E9%80%BB%E8%BE%91%E7%AE%97%E6%B3%95.PNG"></p><p>Sugeno型模糊逻辑区</p><p><img src="/2024/03/18/simulinkNote/T-S%E6%A8%A1%E7%B3%8A%E9%80%BB%E8%BE%91%E7%AE%97%E6%B3%95.PNG"></p><h4 id="隶属函数编辑器"><a href="#隶属函数编辑器" class="headerlink" title="隶属函数编辑器"></a>隶属函数编辑器</h4><p>任意单击输入与输出量模框即可进入MF编辑器。</p><h5 id="Mamdani型MF的编辑"><a href="#Mamdani型MF的编辑" class="headerlink" title="Mamdani型MF的编辑"></a>Mamdani型MF的编辑</h5><ol><li><p>编辑输入&#x2F;出变量的论域(Range)与显示范围(Dispaly Range)。</p></li><li><p>增加覆盖输入&#x2F;出量模糊子集的数目。</p></li><li><p>修改隶属函数曲线：命名，MF类型，非标准函数型MF的修编(拖动拐点与修改参数)</p></li><li><p>修改模糊子集位置：拖动法</p></li></ol><h5 id="Sugeno型MF的编辑"><a href="#Sugeno型MF的编辑" class="headerlink" title="Sugeno型MF的编辑"></a>Sugeno型MF的编辑</h5><p>两种类型推理的输出结论不大相同，前者输出模糊子集，而后者模糊推理输出的是线性函数。</p><p><img src="/2024/03/18/simulinkNote/T-S%E5%9E%8BMF%E8%BE%93%E5%87%BA%E7%95%8C%E9%9D%A2.PNG"></p><h4 id="模糊规则编辑器"><a href="#模糊规则编辑器" class="headerlink" title="模糊规则编辑器"></a>模糊规则编辑器</h4><p>输入量与输出量间的模糊蕴含关系R，用F条件命题对他们进行表述。</p><ol><li><p>Edit与Options的子菜单列表</p><table><thead><tr><th>edit</th><th>Options</th><th></th></tr></thead><tbody><tr><td>Undo</td><td>Language</td><td>Format</td></tr><tr><td>FIS properties…(调出FIS编辑器)</td><td>English</td><td>Verbose(语言型)</td></tr><tr><td>Membership Functions…(调出MF编辑器)</td><td>Deutsch</td><td>Symbolic</td></tr><tr><td>Anfis</td><td>Francais</td><td>Indexed</td></tr></tbody></table></li><li><p>模糊规则的编辑方法</p></li></ol><p>点击Edit-Membership或输入&#x2F;出框图进入隶属函数编辑器，即可通过点击不同的模糊子集与功能键实现输出与输出模糊子集的添加，删除与修改及论域的调整。</p><p>点击Edit-Rules或中间的规则框图即可进入模糊规则编辑器。</p><h4 id="模糊规则观测窗"><a href="#模糊规则观测窗" class="headerlink" title="模糊规则观测窗"></a>模糊规则观测窗</h4><p>点击View-Rules即可进入模糊规则观测窗，可以看到不同输入后的模糊推理与清晰化结果。</p><p>点击上面的surface则可看到模糊规则的三维图</p><h3 id="模糊控制系统的设计与仿真"><a href="#模糊控制系统的设计与仿真" class="headerlink" title="模糊控制系统的设计与仿真"></a>模糊控制系统的设计与仿真</h3><h4 id="FIS与Simulink的连接"><a href="#FIS与Simulink的连接" class="headerlink" title="FIS与Simulink的连接"></a>FIS与Simulink的连接</h4><p> 一般使用<strong>Fuzzy Logic Controller</strong>,右键点击“<strong>Look Under Mask</strong>”即可看到内部结构，使用时需要把使用GUI编辑的FIS结构文件嵌入模块。</p><ol><li>送入工作空间在嵌入</li><li>保存到文件在嵌入</li></ol><h4 id="构建模糊控制系统的仿真模型图"><a href="#构建模糊控制系统的仿真模型图" class="headerlink" title="构建模糊控制系统的仿真模型图"></a>构建模糊控制系统的仿真模型图</h4><ol><li>构建FIS结构文件</li><li>构建仿真模型图</li><li>进行仿真</li></ol><p>熟悉常用模块</p><h4 id="通过仿真对系统进行分析"><a href="#通过仿真对系统进行分析" class="headerlink" title="通过仿真对系统进行分析"></a>通过仿真对系统进行分析</h4><p>有许许多多的模糊模型仿真示例</p><p><img src="/2024/03/18/simulinkNote/MATLAB%E6%A8%A1%E7%B3%8A%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E7%A4%BA%E4%BE%8B.PNG"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
    <tags>
      
      <tag>simulink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh deploy</title>
    <link href="/2023/06/07/ssh-deploy/"/>
    <url>/2023/06/07/ssh-deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="配置github的ssh密钥"><a href="#配置github的ssh密钥" class="headerlink" title="配置github的ssh密钥"></a>配置github的ssh密钥</h1><p>可见<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys">官方链接</a>，及相关<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/using-ssh-agent-forwarding">ssh配置代理转发</a></p><p>输入 <code>ls -al ~/.ssh</code> 以查看是否存在现有的 SSH 密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~/.ssh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Lists the files <span class="hljs-keyword">in</span> your .ssh directory, <span class="hljs-keyword">if</span> they exist</span><br></code></pre></td></tr></table></figure><p>检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，GitHub 的一个支持的公钥的文件名是以下之一。</p><ul><li>id_rsa.pub</li><li>id_ecdsa.pub</li><li>id_ed25519.pub</li></ul><ol><li>设置用户名与邮箱</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name ‘zhandehuang’</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email ‘it_zdh@163.com’</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成新的ssh密钥(选择不同的加密方式)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br>ssh-keygen -t rsa -C &quot;it_zdh@163.com&quot;<br></code></pre></td></tr></table></figure><p>按照提示输入密钥文件名和密码，直接输入回车选择默认名称与无密码。</p><ol start="3"><li>后台启动ssh代理，并将生成密钥加入ssh-agent</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动ssh代理</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Agent pid 59566</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">id_ed25519变为你生成的本地密钥文件名称，有时候需要重新输入该命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/id_ed25519</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将ssh公钥添加到github仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将生成的公钥文件内容加入到/settings/SSH and GPG keys的SSH keys中</span><br>cat ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><ol start="5"><li>测试连接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hi USERNAME! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">provide shell access.</span></span><br></code></pre></td></tr></table></figure><ol start="6"><li>配置ssh代理转发</li></ol><p>使用你喜欢的文本编辑器打开位于 <code>~/.ssh/config</code> 的文件。 如果此文件不存在，则可以通过在终端中输入 <code>touch ~/.ssh/config</code> 来创建它。在文件中输入以下文本，将 <code>*.github.com</code> 替换为服务器的域名或 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host *.github.com<br>  ForwardAgent yes<br></code></pre></td></tr></table></figure><p>如果不确定是否在使用本地密钥，还可以检查服务器上的 <code>SSH_AUTH_SOCK</code> 变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SSH_AUTH_SOCK</span>&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Print out the SSH_AUTH_SOCK variable</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/tmp/ssh-4hNGMk8AZX/agent.79453</span><br></code></pre></td></tr></table></figure><hr><p>注意事项：</p><ul><li>对于windows下，每次打开git bash都可能需要<code>eval &quot;$(ssh-agent -s)&quot;</code>与<code>ssh-add ~/.ssh/id_ed25519</code>来重新打开agent并加入本地密钥，可利用<code>ssh-add -l</code>检查此时是否打开agent及密钥。</li><li>尽量使用一个git bash进行操作。</li></ul><p>版本: 1.85.1 (user setup)<br>提交: 0ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2<br>日期: 2023-12-13T09:49:37.021Z<br>Electron: 25.9.7<br>ElectronBuildId: 25551756<br>Chromium: 114.0.5735.289<br>Node.js: 18.15.0<br>V8: 11.4.183.29-electron.0<br>OS: Windows_NT x64 10.0.19045</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">scp vscode-<span class="hljs-keyword">server</span>-linux-x64.tar.gz cute@<span class="hljs-number">192.168</span><span class="hljs-number">.43</span><span class="hljs-number">.253</span>:~/.vscode-<span class="hljs-keyword">server</span>/bin<br><br>mv vscode-<span class="hljs-keyword">server</span>-linux-x64 <span class="hljs-number">0</span>ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2<br>rm vscode-<span class="hljs-keyword">server</span>-linux-x64.tar.gz<br><br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2023/06/05/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/06/05/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>测试</p><span id="more"></span><p>&lt;</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br><span class="hljs-variable">$ </span>hexo g   <span class="hljs-comment"># 生成页面</span><br><span class="hljs-variable">$ </span>hexo d   <span class="hljs-comment"># 部署发布</span><br></code></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></p><p><a href="http://www.lzqlearn.com/blog/6560820db005/#2-4-5-%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E6%A0%B7%E5%BC%8F">参考他人博客</a><br><a href="https://zahui.fan/posts/64b52e0d/">typora下载 </a>  <a href="https://rufus.ie/zh/#google_vignette">Rufus启动盘创建</a><br><a href="https://andavid.github.io/2019/01/15/insert-local-image-in-hexo/">使用hexo插入图片</a>可以使用hexo-renderer-marked及hexo-asset-image(node_modules\hexo-asset-image\index.js第58行代码)插件(后者更为简易，高版本或许不适配),但是默认的渲染器并不支持latex公式，因此使用hexo-renderer-marked存在公式渲染问题<a href="https://seekstar.github.io/2021/11/16/hexo%E6%94%AF%E6%8C%81latex%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/">hexo渲染公式</a>。<br><a href="https://qllokirin.github.io/">wh博客</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BoardBall</title>
    <link href="/2023/05/28/BoardBall/"/>
    <url>/2023/05/28/BoardBall/</url>
    
    <content type="html"><![CDATA[<h1 id="板球系统基本原理"><a href="#板球系统基本原理" class="headerlink" title="板球系统基本原理"></a>板球系统基本原理</h1><p>根据拉格朗日广义方程，结合小角度线性化可得到：</p><p>$\begin{aligned}&amp;\dot{\mathbf{x}}_x&#x3D;A_x\mathbf{x}_x+b_xu_x\ &amp;y_x&#x3D;[1, 0 ,0 ,0] \mathbf{x}_x\ &amp;A_\mathrm{x}&#x3D;\begin{bmatrix}0&amp;1&amp;0&amp;0\0&amp;0&amp;-7.007&amp;0\0&amp;0&amp;0&amp;1\0&amp;0&amp;0&amp;0\end{bmatrix},b_\mathrm{x}&#x3D;\begin{bmatrix}0\0\0\1\end{bmatrix}\end{aligned}$</p><p>式中，$\dot{X}_x&#x3D; [x,v,\alpha,\dot{\alpha}]^T$</p><h1 id="基于BP神经网络的PID控制器"><a href="#基于BP神经网络的PID控制器" class="headerlink" title="基于BP神经网络的PID控制器"></a>基于BP神经网络的PID控制器</h1><h2 id="传统PID控制"><a href="#传统PID控制" class="headerlink" title="传统PID控制"></a>传统PID控制</h2><h1 id="PIDNN（PID神经网络）"><a href="#PIDNN（PID神经网络）" class="headerlink" title="PIDNN（PID神经网络）"></a>PIDNN（PID神经网络）</h1><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>matlab笔记</title>
    <link href="/2023/02/07/matlabNote/"/>
    <url>/2023/02/07/matlabNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Matlab符号计算"><a href="#Matlab符号计算" class="headerlink" title="Matlab符号计算"></a>Matlab符号计算</h1><h2 id="1-符号对象简介"><a href="#1-符号对象简介" class="headerlink" title="1.符号对象简介"></a>1.符号对象简介</h2><h3 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h3><p>符号对象属于MATLAB语言中数据类型之一。符号对象是符号的字符串表示。符号对象主要用于表示：</p><p>符号常量，符号变量，符号函数，各种符号表达式</p><h3 id="符号运算和数值运算的差别"><a href="#符号运算和数值运算的差别" class="headerlink" title="符号运算和数值运算的差别"></a>符号运算和数值运算的差别</h3><ul><li><p>符号运算的结果用分数，幂指数等形式表示。</p></li><li><p>表达式中有一个为符号数据，则整个表达式的计算结果是一个符号数据。</p></li><li><p>数值型表达式计算的结果为数值型数据（包括整型、浮点型）。</p></li></ul><p>可以看出：当采用符号运算时并不直接给出表达式的数值结果，而是给出符号表达。如果要查看符号b所代表的数值，可以使用double()函数。</p><p>符号运算的结果用分数，幂指数等形式表示。</p><h3 id="符号变量和符号表达式的生成"><a href="#符号变量和符号表达式的生成" class="headerlink" title="符号变量和符号表达式的生成"></a>符号变量和符号表达式的生成</h3><p>符号变量是在MATLAB的符号计算中内容可变的符号对象。符号变量与数值变量名称的命名规则相同。可以用命令<code>sym</code>或者<code>syms</code>来建立符号变量，分别用于单个符号变量和多个符号变量的定义.</p><h3 id="“查找”和-“替换”字符变量函数用法"><a href="#“查找”和-“替换”字符变量函数用法" class="headerlink" title="“查找”和 “替换”字符变量函数用法"></a>“查找”和 “替换”字符变量函数用法</h3><ol><li><code>symvar</code>函数用于确定符号表达式中符号变量</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">C = symvar(expr) <span class="hljs-comment">%搜索表达式 expr，查找除 i、j、pi、inf、nan、eps 和公共函数之外的标识符。这些标识符是表达式中变量的名称。symvar 返回字符向量元胞数组 C 中的标识符。如果 symvar 找不到标识符，则 C 是一个空的元胞数组。</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>subs</code>函数用于将符号表达式中的符号变量替换为其他符号变量或数值</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subs(s,old,new)<span class="hljs-comment">%将符号表达式s中所有字符变量old用new替换后将结果返回s</span><br>subs(s,new)    <span class="hljs-comment">%subs(s,new) 将符号表达式s中所有默认的字符变量（一般为一个）用new替换后将结果返回s，默认变量可以通过symvar进行查询。</span><br></code></pre></td></tr></table></figure><h3 id="符号和数值之间的转换"><a href="#符号和数值之间的转换" class="headerlink" title="符号和数值之间的转换"></a>符号和数值之间的转换</h3><ol><li>数值型转换为符号型 <code>sym(x)</code> 或者<code>sym (x,’flag’)</code></li></ol><p>Flag可以是’r’-有理数，’d’-十进制数，’e’-估计误差，’f’-浮点数 </p><ol start="2"><li>字符型转换为数值型<code>double()</code></li></ol><h3 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h3><h3 id="任意精度的计算"><a href="#任意精度的计算" class="headerlink" title="任意精度的计算"></a>任意精度的计算</h3><p>符号计算的优点：不会产生舍入误差，从而可以得到任意精度的数值解<br>符号计算的缺点：需要更多的计算时间和存储空间<br>MATLAB工具箱中3种不同类型的算术运算<br>（1）数值型：浮点数<br>（2）有理数类型：Maple精确符号运算<br>（3）Vpa型：Maple任意精度算术运算</p><h2 id="2-符号表达式的替换与化简"><a href="#2-符号表达式的替换与化简" class="headerlink" title="2.符号表达式的替换与化简"></a>2.符号表达式的替换与化简</h2><h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p><code>expand</code>函数：expand(s)函数能对表达式s进行<strong>因式展开</strong>,常用于多项式、三角函数、指数函数和对数函数。 </p><p><code>factor</code>函数：<strong>因式分解</strong>，factor(s)，s可以是正整数、符号整数、符号表达式或符号矩阵。当s为正整数时，因式分解的结果返回的是s的质数分解式。当s为符号表达式时，结果返回乘积形式。</p><p><code>collect</code>函数：进行符号表达式<strong>同类项合并</strong>。</p><p><code>simplify</code>函数：根据一定规则对符号表达式进行<strong>化简</strong>，它可以完成对指数、对数、三角函数等各种数学表达式的化简。</p><p><code>horner</code>函数：将多项式转换为<strong>嵌套格式</strong>，该格式在多项式求值中可以降低计算时间复杂度。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>subexpr</code>函数：调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[r,sigma] = subexpr(expr)<br><span class="hljs-comment">%使用重复出现的字符串改写表达式expr，重复的字符串用sigma代替，改写后表达式通过r输出</span><br>[r,var] = subexpr(expr,<span class="hljs-string">&#x27;var&#x27;</span>)<br>[r,var] = subexpr(expr,var)<br><span class="hljs-comment">%使用工作空间中已有的字符变量 var或者未有的变量’var’改写表达式expr，重复的字符串用var表示，改写后的表达式通过r输出。</span><br></code></pre></td></tr></table></figure><p><code>subs</code>函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R= subs(s,new)<br><span class="hljs-comment">%使用新的符号变量new代替s表达式中所有默认的变量，即由symvar函数返回变量。</span><br> subs(s,old,new)<br><span class="hljs-comment">%使用新的符号变量new代替s表达式中所有变量old。</span><br></code></pre></td></tr></table></figure><h2 id="3-符号函数图像绘制"><a href="#3-符号函数图像绘制" class="headerlink" title="3.符号函数图像绘制"></a>3.符号函数图像绘制</h2><h3 id="3-1符号函数曲线绘制"><a href="#3-1符号函数曲线绘制" class="headerlink" title="3.1符号函数曲线绘制"></a>3.1符号函数曲线绘制</h3><p>MATLAB中<code>ezplot</code>函数和<code>ezplot3</code>函数分别实现符号函数二维和三维曲线的绘制。(在matlab中推荐使用<code>fplot</code>函数，此函数输入参数指定为<strong>命名或匿名函数的函数句柄</strong>。)</p><blockquote><p>对于<code>ezplot</code>,其输入参数f的选取，</p><p>在使用<strong>函数句柄传递</strong>时，必须使用数组幂、数组乘法和数组除法运算符 (<code>.^, .*, ./</code>)，因为在有字符向量或字符串输入的情况下 <code>ezplot</code> 不改变语法。而在<strong>字符向量与字符串形式传递</strong>函数时，<code>x^2</code> 解释为 <code>x.^2</code>。</p></blockquote><h4 id="显函数绘制"><a href="#显函数绘制" class="headerlink" title="显函数绘制"></a>显函数绘制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(f) <span class="hljs-comment">%绘制函数f在区间[-2pi, 2pi]内的图像；</span><br>ezplot(f, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>])  <span class="hljs-comment">%绘制函数f在指定区间[min, max] 内的图像；</span><br>ezplot(f, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>], fign) <span class="hljs-comment">%在指定的窗口fign中，绘制函数f在指定区间[min, max] 内的图像。</span><br><span class="hljs-comment">%% fplot不支持符号表达式作为输入参数，只可以使用函数句柄传递。在绘制显函数时类似</span><br></code></pre></td></tr></table></figure><h4 id="隐函数绘制"><a href="#隐函数绘制" class="headerlink" title="隐函数绘制"></a>隐函数绘制</h4><p>符号变量隐函数使用时可以使用<code>ezplot</code>,但是不能使用<code>fplot</code>，但是可以使用传入函数句柄的<code>fimplic</code>隐函数绘制函数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(f)  <span class="hljs-comment">%绘制函数f(x,y)=0在区间x和y在[-2pi, 2pi]内的图像；</span><br>ezplot(f, [xmin, xmax, ymin, ymax]) <span class="hljs-comment">%绘制函数在指定区间[xmin, xmax] 、[ymin, ymax]内的图像；</span><br></code></pre></td></tr></table></figure><h4 id="参数方程绘制"><a href="#参数方程绘制" class="headerlink" title="参数方程绘制"></a>参数方程绘制</h4><p><code>ezplot</code>与<code>fplot</code>均可以绘制参数方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(x, y) <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)在区间[0, 2pi]内的曲线；</span><br>ezplot(x, y，[tmin, tmax]) <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)在区间[tmin, tmax]内的曲线；</span><br>fplot(funx,funy,tinterval) <span class="hljs-comment">%将在指定区间绘图。将区间指定为 [tmin tmax] 形式的二元素向量。</span><br></code></pre></td></tr></table></figure><h4 id="三维曲线绘制"><a href="#三维曲线绘制" class="headerlink" title="三维曲线绘制"></a>三维曲线绘制</h4><p>使用<code>ezplot</code>与<code>fplot</code>均可绘制三维曲线，区别也只是后者只能传入命名函数或者匿名函数句柄</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot3(x, y, z), <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)，z=z(t)在区间[0, 2pi]内的图像；</span><br>ezplot3(x, y，z, [tmin, tmax])  <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t), z=z(t) 在区间[tmin, tmax]内的曲线；</span><br>ezplot3(…, ‘animate’) <span class="hljs-comment">%生成空间曲线的动态轨迹。</span><br></code></pre></td></tr></table></figure><h3 id="3-2符号函数曲面绘制"><a href="#3-2符号函数曲面绘制" class="headerlink" title="3.2符号函数曲面绘制"></a>3.2符号函数曲面绘制</h3><p>MATLAB中<code>ezmesh</code>、<code>ezmeshc</code>、<code>ezsurf</code>、<code>ezsurfc</code>函数实现三维网格图，曲面图的绘制，其中后两者会绘<strong>制等值线</strong>图。</p><p>有相应的<code>fmesh</code>，<code>fsurf</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezmesh(f), <span class="hljs-comment">%绘制函数f(x,y)的图像</span><br>ezmesh(f，domain), <span class="hljs-comment">%指定区域绘制函数f(x,y)的图像</span><br>ezmesh(x, y, z), <span class="hljs-comment">%在默认区域绘制三维参数方程图像</span><br>ezmesh(x,y,z，[smin, smax, tmin, tmax])<br>ezmesh(x,y, z, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>]) <span class="hljs-comment">%在指定区域绘制三维参数方程的图像。</span><br><br>ezmeshc(f), 绘制函数f(x,y)在默认区域[<span class="hljs-number">-2</span><span class="hljs-built_in">pi</span>, <span class="hljs-number">2</span><span class="hljs-built_in">pi</span>] 的图像<br>ezmeshc(f，domain), 指定区域绘制函数f(x,y)的图像，domain为<span class="hljs-number">4</span>×<span class="hljs-number">1</span>或<span class="hljs-number">2</span>×<span class="hljs-number">1</span>数组<br>ezmeshc(x, y, z), 在默认区域绘制三维参数方程图像<br>ezmeshc(x, y, z， [smin, smax, tmin, tmax])或ezmeshc(x,y, z, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>] <span class="hljs-comment">%在指定区域绘制三维参数方程的图像。</span><br>ezmeshc(…, n)，<span class="hljs-comment">%指定绘图的网格数，默认为60</span><br>ezmeshc(…, ‘circ’)<span class="hljs-comment">%在以指定区域为中心的原盘上绘制图形</span><br></code></pre></td></tr></table></figure><h3 id="3-3-等值线绘制"><a href="#3-3-等值线绘制" class="headerlink" title="3.3 等值线绘制"></a>3.3 等值线绘制</h3><p>MATLAB中<code>ezcontour</code>和<code>ezcontourf</code>这两个函数分别用于绘制等值线和带有<strong>区域填充</strong>的等值线。以<code>ezcontour</code>函数为例进行介绍。同时也有相应的<code>fcounter</code>函数（调整Fill参数即可实现区域填充）。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezcontour(f), <span class="hljs-comment">%绘制符号二元函数f(x,y)在默认区域内的等值线图像</span><br>ezcontour(f，domain), <span class="hljs-comment">%绘制符号二元函数f(x,y)在指定区域内的等值线图像</span><br>ezcontour(…, n), <span class="hljs-comment">%绘制等值线，并指定等值线数目。</span><br><br>fcontour(@(x,y) <span class="hljs-built_in">erf</span>((y+<span class="hljs-number">2</span>).^<span class="hljs-number">3</span>) - <span class="hljs-built_in">exp</span>(<span class="hljs-number">-0.65</span>*((x<span class="hljs-number">-2</span>).^<span class="hljs-number">2</span>+(y<span class="hljs-number">-2</span>).^<span class="hljs-number">2</span>)),<span class="hljs-string">&#x27;Fill&#x27;</span>,<span class="hljs-string">&#x27;on&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-符号微积分"><a href="#4-符号微积分" class="headerlink" title="4.符号微积分"></a>4.符号微积分</h2><hr><h4 id="4-1符号表达式求极限"><a href="#4-1符号表达式求极限" class="headerlink" title="4.1符号表达式求极限"></a>4.1符号表达式求极限</h4><p>函数<code>limit</code>用于求符号表达式的极限，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">Limit(F, x, a)，<span class="hljs-comment">%当x趋近于a时表达式F的极限。</span><br>Limit(F, a)，<span class="hljs-comment">%当F中的自变量趋近于a时表达式F的极限，自变量由symvar函数确定。</span><br>Limit(F)，<span class="hljs-comment">%当F中的自变量趋近于0时表达式F的极限，自变量由symvar函数确定。</span><br>Limit(F, x, a, ‘right’)，<span class="hljs-comment">%当x从右侧趋近于a时F的极限。</span><br>Limit(F, x, a, ‘left’)，<span class="hljs-comment">%当x从左侧趋近于a时F的极限。</span><br></code></pre></td></tr></table></figure><h4 id="4-2符号微分"><a href="#4-2符号微分" class="headerlink" title="4.2符号微分"></a>4.2符号微分</h4><p>函数<code>diff</code>用于函数求导和求微分，包括一元函数和多元函数。该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">diff(S)，<span class="hljs-comment">%求表达式S的导数，自变量由symvar确定。</span><br>diff(S, ‘v’)，<span class="hljs-comment">%求表达式S对指定变量v的导数，或者diff(S, sym(‘v’))。</span><br>diff(S, n)，<span class="hljs-comment">%求S的n阶导数</span><br>diff(S, ‘v’,n) <span class="hljs-comment">%求S对v的n阶导数，或者diff(S,n,’v’)</span><br></code></pre></td></tr></table></figure><p>MATLAB中<code>Jacobian</code>用于计算jocobian矩阵，该函数调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R=jacobian(f,v)<br><span class="hljs-comment">%如果f是函数向量，v为自变量向量，则计算f的jacobian矩阵，如果f是标量，则计算f的梯度，如果v也是标量，则结果与diff函数相同。</span><br></code></pre></td></tr></table></figure><h4 id="4-3符号积分"><a href="#4-3符号积分" class="headerlink" title="4.3符号积分"></a>4.3符号积分</h4><p>函数<code>int</code>用于求表达式的积分，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R=int(S)，<span class="hljs-comment">%求表达式S的不定积分，自变量通过symvar确定。</span><br>R=int(S,v)，<span class="hljs-comment">%求表达式S对自变量v的不定积分。</span><br>R=int(S, a, b)，<span class="hljs-comment">%求表达式S在区间[a,b]内的定积分。</span><br>R=int(S, v，a, b)，<span class="hljs-comment">%求表达式S在区间[a,b]内的定积分，自变量为v。</span><br></code></pre></td></tr></table></figure><h4 id="4-4级数求和"><a href="#4-4级数求和" class="headerlink" title="4.4级数求和"></a>4.4级数求和</h4><p>函数<code>symsum</code>用于级数求和，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r=symsum(s, v, a, b)，<span class="hljs-comment">%计算变量v从a到b之间s的和。</span><br>r=symsum(s)，<span class="hljs-comment">%自变量通过symvar确定，设其为k，则计算s从0到k-1的和。</span><br>r=symsum(s,v)，<span class="hljs-comment">%计算表达式s从0到v-1的和。</span><br>r=symsum(s, a, b)，<span class="hljs-comment">%计算自变量从a到b之间s的和。</span><br><br>symsum(x^k/<span class="hljs-built_in">factorial</span>(k), k, <span class="hljs-number">0</span>, <span class="hljs-built_in">inf</span>)<br></code></pre></td></tr></table></figure><h4 id="4-5泰勒级数"><a href="#4-5泰勒级数" class="headerlink" title="4.5泰勒级数"></a>4.5泰勒级数</h4><p>函数<code>taylor</code>用于实现taylor级数的计算。该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r=taylor(f)，<span class="hljs-comment">%计算表达式f的泰勒级数，自变量由symvar确定，计算f在0的不超过5阶泰勒级数。</span><br>r=taylor(f, x, a)，<span class="hljs-comment">%计算表达式f在自变量x=a处泰勒级数。</span><br>r=taylor(f, x, ‘order’, n)，<span class="hljs-comment">%计算表达式f在自变量x处n阶泰勒级数。</span><br></code></pre></td></tr></table></figure><h3 id="5-符号方程求解"><a href="#5-符号方程求解" class="headerlink" title="5.符号方程求解"></a>5.符号方程求解</h3><h4 id="5-1代数方程及方程组组求解"><a href="#5-1代数方程及方程组组求解" class="headerlink" title="5.1代数方程及方程组组求解"></a>5.1代数方程及方程组组求解</h4><p>代数方程包括线性方程、非线性方程和超越方程等。在 MATLAB 中函数 <code>solve</code> 用于求解代数方程和方程组，其调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g = solve(eq)，<span class="hljs-comment">%求解方程 eq 的解，对默认自变量求解，输入的参数 eq 可以是符号表达式或字符串；</span><br>g = solve(eq,var)，<span class="hljs-comment">%求解方程 eq 的解，对指定自变量求解。</span><br>g = solve(eq1,eq2,...,eqn)，<span class="hljs-comment">%求由方程 eq1、eq2、…、eqn 等组成的系统，自变量为默认自变量；</span><br>g = solve(eq1,eq2,...,eqn,var1,var2,...,varn)，<span class="hljs-comment">%求由方程eq1、eq2、…、eqn 等组成的系统，自变量为指定的自变量：var1、var2、…、varn。</span><br></code></pre></td></tr></table></figure><h4 id="5-2微分方程及方程组的求解"><a href="#5-2微分方程及方程组的求解" class="headerlink" title="5.2微分方程及方程组的求解"></a>5.2微分方程及方程组的求解</h4><p>微分方程的求解通过函数 <code>dsolve</code> 进行，该函数用于求解常微分方程。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r = dsolve(‘eq1,eq2,...’, ‘cond1,cond2,...’, ‘v’)<br>r = dsolve (<span class="hljs-string">&#x27;eq1&#x27;</span>,<span class="hljs-string">&#x27;eq2&#x27;</span>,...,<span class="hljs-string">&#x27;cond1&#x27;</span>,<span class="hljs-string">&#x27;cond2&#x27;</span>,...,<span class="hljs-string">&#x27;v&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中eq1, eq2等表示待求解的方程，默认自变量t。方程中<strong>用D表示微分</strong>，<strong>D后面的数字表示高阶导数</strong>。Cond1, cond2等表示初始值，通常表示为y(a)&#x3D;b或者Dy(a)&#x3D;b的形式。注意每一个方程应该带上<strong>单引号</strong>，结果放在结构体里。</p><h4 id="5-3复合方程求解"><a href="#5-3复合方程求解" class="headerlink" title="5.3复合方程求解"></a>5.3复合方程求解</h4><p>复合方程通过函数 <code>compose</code> 进行：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">compose(f,g)，<span class="hljs-comment">%返回函数 f(g(y))，其中 f = f(x)，g = g(y)，x 是 f 的默认自变量，y 是 g 的默认自变量；</span><br>compose(f,g,z)，<span class="hljs-comment">%返回函数 f(g(z))，自变量为 z；</span><br>compose(f,g,x,z)，<span class="hljs-comment">%返回函数 f(g(z))，指定 f 的自变量为 x；</span><br>compose(f,g,x,y,z)，<span class="hljs-comment">%返回函数 f(g(z))，f 和 g 的自变量分别指定为 x 和 y。</span><br></code></pre></td></tr></table></figure><h4 id="5-4符号反函数求解"><a href="#5-4符号反函数求解" class="headerlink" title="5.4符号反函数求解"></a>5.4符号反函数求解</h4><p>反方程通过函数 <code>finverse</code> 求得：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g = finverse(f)，<span class="hljs-comment">%在函数 f 的反函数存在的情况下，返回函数 f 的反函数，自变量为默认自变量；</span><br>g = finverse(f,v)，<span class="hljs-comment">%在函数 f 的反函数存在的情况下，返回函数 f 的反函数，自变量为 v。</span><br></code></pre></td></tr></table></figure><h3 id="6-符号积分变换"><a href="#6-符号积分变换" class="headerlink" title="6.符号积分变换"></a>6.符号积分变换</h3><hr><h4 id="6-1符号拉普拉斯变换"><a href="#6-1符号拉普拉斯变换" class="headerlink" title="6.1符号拉普拉斯变换"></a>6.1符号拉普拉斯变换</h4><ol><li><p>傅立叶变换</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = fourier(f)，<span class="hljs-comment">%实现函数f的傅立叶变换，如果 f 的默认自变量为 x，则返回 f 的傅立叶变换结果，默认自变量为w；如果 f 的默认自变量为w，则返回结果的默认自变量为 t。</span><br>F = fourier(f, v)，<span class="hljs-comment">%返回结果为v的函数。</span><br>F = fourier(f, u, v)，<span class="hljs-comment">%f的自变量为u，返回结果为v的函数。</span><br></code></pre></td></tr></table></figure></li><li><p>傅立叶逆变换</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = ifourier(F)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，如果F的默认自变量为w，则返回结果f的默认自变量为x，如果F的自变量为x，则返回结果f的自变量为t。</span><br>f = ifourier(F,u)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，返回结果f为u的函数； </span><br>f = ifourier(F,v,u)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，F的自变量为v，返回结果f为u的函数。</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="6-2符号拉普拉斯变换"><a href="#6-2符号拉普拉斯变换" class="headerlink" title="6.2符号拉普拉斯变换"></a>6.2符号拉普拉斯变换</h4><ol><li>拉普拉斯变换</li></ol><pre><code class="hljs"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">laplace(F)，<span class="hljs-comment">%实现函数F的拉普拉斯变换，如果F的默认自变量为t，返回结果的默认自变量为s如果F的默认自变量为s，则返回结果为t的函数。</span><br>laplace(F, t)，<span class="hljs-comment">%返回函数的自变量为t。</span><br>laplace(F, w, z)，<span class="hljs-comment">%指定F的自变量为w，返回结果为z的函数拉普拉斯逆变换</span><br></code></pre></td></tr></table></figure></code></pre><ol start="2"><li>拉普拉斯逆变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ilaplace(L)，<span class="hljs-comment">%实现函数L的拉普拉斯逆变换，如果L的自变量为s，则返回结果为t的函数；如果L的自变量为t，则返回结果为x的函数。</span><br> F = ilaplace(L, y)，<span class="hljs-comment">%返回结果为y的函数。</span><br> F = ilaplace(L, y, x)，<span class="hljs-comment">%指定L的自变量为y，返回结果为x的函数。</span><br></code></pre></td></tr></table></figure><h4 id="6-3符号Z变换"><a href="#6-3符号Z变换" class="headerlink" title="6.3符号Z变换"></a>6.3符号Z变换</h4><ol><li>Z变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ztrans(f)，<span class="hljs-comment">%如果f的默认自变量为n，则返回结果为z的函数，如果f  为函数z的函数，则返回结果为w的函数。</span><br> F = ztrans(f, w)，<span class="hljs-comment">%返回结果为w的函数。</span><br> F = ztrans(f, k, w)，<span class="hljs-comment">%f的自变量为k，返回结果为w的函数。</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Z 逆变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = iztrans(F)，<span class="hljs-comment">%若F的默认自变量为z，则返回结果为n 的函数；如果F是n 的函数，则返回结果为k的函数。</span><br>f = iztrans(F, k)，<span class="hljs-comment">%指定返回结果为k的函数。</span><br>f = iztrans(F, w, k)，<span class="hljs-comment">%指定F的自变量为w，返回结果为k的函数。</span><br></code></pre></td></tr></table></figure><h3 id="7-符号函数计算器"><a href="#7-符号函数计算器" class="headerlink" title="7.符号函数计算器"></a>7.符号函数计算器</h3><h4 id="7-1单变量符号函数计算器"><a href="#7-1单变量符号函数计算器" class="headerlink" title="7.1单变量符号函数计算器"></a>7.1单变量符号函数计算器</h4><p>在命令窗口中执行<code>funtool</code>即可调出单变量符号函数计算器。单变量符号函数计算器用于对单变量函数进行操作，可以对符号函数进行化简、求导、绘制图形等。</p><p>控制按钮:d</p><p>f&#x2F;dx&#x3D;: 求函数f 的导数。<br>int f:  求函数f的积分。<br>simplify: 对函数f化简<br>num f: 函数f的分子<br>den f: 函数f的分母<br>第2行为函数与常数a之间的操作<br>第3行为函数f与函数g之间的操作<br>第4行功能按钮作用如下：<br>Insert 将函数f加入到函数列表中<br>Cycle 将函数列表中下一个函数代替f值<br>Delete 将f从函数列表中删去<br>Reset 重置计算器                     Help 在线显示帮助<br>Demo 演示                              Close 关闭</p><h4 id="7-2Taylor函数逼近器"><a href="#7-2Taylor函数逼近器" class="headerlink" title="7.2Taylor函数逼近器"></a>7.2Taylor函数逼近器</h4><p>输入<code>taylortool</code>即可进入taylor函数逼近器</p><h1 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h1><p>margin</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear all;clc;<br>ts=<span class="hljs-number">1</span>;  tau=<span class="hljs-number">0.25</span>;L=<span class="hljs-built_in">floor</span>(tau/ts);<br>Gs=tf([<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;inputdelay&#x27;</span>,tau);<br>Gz=c2d(Gs,ts,<span class="hljs-string">&#x27;zoh&#x27;</span>);<br>delay=tf([<span class="hljs-number">1</span>],[<span class="hljs-number">1</span> <span class="hljs-number">0</span>],ts);<br>Gz=Gz*delay;<br>[num,den]=tfdata(Gz,<span class="hljs-string">&#x27;v&#x27;</span>);<br>Gz=filt(num,den,ts);<br>Gz=zpk(Gz);<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">clear</span> <span class="hljs-literal">all</span>;clc;<br><span class="hljs-attribute">G0</span>=tf(<span class="hljs-number">120</span>,conv([<span class="hljs-number">1</span> <span class="hljs-number">0</span>],[<span class="hljs-number">1</span> <span class="hljs-number">4</span>]));<br><span class="hljs-attribute">G</span>=feedback(G0,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">1</span>);bode(G0);grid <span class="hljs-literal">on</span>         %原系统的频域响应<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">2</span>);step(G);grid <span class="hljs-literal">on</span>           %原系统的阶跃响应曲线<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">3</span>);bode(G);grid <span class="hljs-literal">on</span>          %原闭环系统的带宽频率 <br><span class="hljs-attribute">ts</span>=<span class="hljs-number">0</span>.<span class="hljs-number">01</span>;<br><span class="hljs-attribute">Gh</span>=tf(<span class="hljs-number">1</span>,[ts/<span class="hljs-number">2</span> <span class="hljs-number">1</span>]);<br><span class="hljs-attribute">G</span>=G0*Gh;<br><span class="hljs-attribute">Dcs</span>=tf([<span class="hljs-number">0</span>.<span class="hljs-number">2</span> <span class="hljs-number">1</span>],[<span class="hljs-number">0</span>.<span class="hljs-number">02</span> <span class="hljs-number">1</span>]);<br><span class="hljs-attribute">sysc</span>=G*Dcs;<br><span class="hljs-attribute">sys</span>=feedback(sysc,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">Dcz</span>=c2d(Dcs,ts,&#x27;tustin&#x27;);<br><span class="hljs-attribute">Gcz</span>=c2d(G0,ts,&#x27;zoh&#x27;);<br><span class="hljs-attribute">syscz</span>=Dcz*Gcz;<br><span class="hljs-attribute">sysz</span>=feedback(syscz,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">4</span>);step(sys);hold <span class="hljs-literal">on</span>;step(sysz);grid <span class="hljs-literal">on</span><br><span class="hljs-attribute">figure</span>(<span class="hljs-number">5</span>);bode(syscz);grid <span class="hljs-literal">on</span>        %计算机控制系统的频域响应<br><br></code></pre></td></tr></table></figure><h2 id="sim函数使用"><a href="#sim函数使用" class="headerlink" title="sim函数使用"></a>sim函数使用</h2><h2 id="plot便捷实例"><a href="#plot便捷实例" class="headerlink" title="plot便捷实例"></a>plot便捷实例</h2><p><code>DisplayName</code>参数为选择对应图例名称，最后使用legend()统一显示<br><code>HandleVisibility</code>参数为对应图例可见性，选择off即可关闭该plot图例</p><p>grid minor为打开细致网格</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:n_quad<br><br>    <span class="hljs-built_in">plot</span>(t, <span class="hljs-number">-1</span>*pos_desired(<span class="hljs-number">3</span>*<span class="hljs-built_in">j</span>).*<span class="hljs-built_in">ones</span>(step,<span class="hljs-number">1</span> ), <span class="hljs-string">&#x27;DisplayName&#x27;</span>, [sprintf(<span class="hljs-string">&quot;quad_&#123;%dd&#125;&quot;</span>,<span class="hljs-built_in">j</span>)], <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.2</span>);<span class="hljs-built_in">hold</span> on; <br>grid monior; <span class="hljs-comment">%显示细致网格</span><br>    <span class="hljs-built_in">plot</span>(t, <span class="hljs-number">-1</span>*q_list(<span class="hljs-number">3</span>*<span class="hljs-built_in">j</span>,:),<span class="hljs-string">&#x27;DisplayName&#x27;</span>, [sprintf(<span class="hljs-string">&quot;quad_%d&quot;</span>,<span class="hljs-built_in">j</span>)],<span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.2</span>);<span class="hljs-built_in">hold</span> on; grid minor;<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">10</span>);xlabel(<span class="hljs-string">&quot;t / s&quot;</span>);ylabel(<span class="hljs-string">&quot;-z / m&quot;</span>);set(get(gca,<span class="hljs-string">&#x27;XLabel&#x27;</span>), <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">14</span>);set(get(gca,<span class="hljs-string">&#x27;YLabel&#x27;</span>), <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">14</span>);<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/31/hello-world/"/>
    <url>/2023/01/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
