<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>simulinkNote</title>
    <link href="/2024/03/18/simulinkNote/"/>
    <url>/2024/03/18/simulinkNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Simulink常用工具"><a href="#Simulink常用工具" class="headerlink" title="Simulink常用工具"></a>Simulink常用工具</h1><h2 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h2><h2 id="Model-Linearizer"><a href="#Model-Linearizer" class="headerlink" title="Model Linearizer"></a><strong>Model Linearizer</strong></h2><p>​使用 Model Linearizer，您可以分析线性化模型的时域和频域响应。您可以比较多个模型的响应并查看稳定裕度和稳定时间等系统特性。</p><p>参考官网链接:<a href="https://ww2-mathworks-cn.translate.goog/help/slcontrol/ug/linearize-simulink-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型工作点线性化Simulink 模型</a>,   <a href="https://ww2-mathworks-cn.translate.goog/help/slcontrol/ug/analyze-results-using-linear-analysis-tool-response-plots-1.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">使用模型线性化器响应图分析结果使用模型线性化器响应图分析结果</a>  <a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/specify-portion-of-model-to-linearize-in-linear-analysis-tool.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型线性化器中指定要线性化的模型部分</a></p><table><thead><tr><th></th><th>Simulink Control Design Linearization</th></tr></thead><tbody><tr><td>图形用户界面</td><td>是的。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/linearize-simulink-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型工作点线性化 Simulink 模型</a>。</td></tr><tr><td>灵活定义模型的哪一部分进行线性化</td><td>是的。允许您以图形方式或编程方式在 Simulink 模型的任何级别指定线性化 I&#x2F;O 点，而无需修改您的模型。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/linearize-at-trimmed-operating-point.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在修整的工作点进行线性化</a>。</td></tr><tr><td>开环分析</td><td>是的。允许您在不删除模型中的反馈信号的情况下打开反馈回路。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/open-loop-response-of-control-system-for-stability-margin-analysis.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">计算开环响应</a>。</td></tr><tr><td>控制线性模型状态排序</td><td>是的。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/state-order-in-linearized-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">线性化模型中的顺序状态</a>。</td></tr><tr><td>控制单个块的线性化</td><td>是的。允许您为模块和子系统指定自定义线性化行为。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/when-to-specify-individual-block-linearization.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">何时指定单个块线性化</a>。</td></tr><tr><td>线性化诊断</td><td>是的。识别有问题的块并让您检查每个块的线性化值。请参阅<a href="https://www-mathworks-com.translate.goog/help/slcontrol/ug/linearization-troubleshooting-overview.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">线性化故障排除概述</a>。</td></tr><tr><td>块检测和减少</td><td>是的。块缩减检测对整体线性化没有贡献的块，从而产生最小实现。</td></tr><tr><td>多速率模型速率转换算法的控制</td><td>是的</td></tr></tbody></table><p>分析点类型：</p><ul><li><strong>Input Perturbation</strong> — Specifies an additive input to a signal.</li><li><strong>Output Measurement</strong> — Takes a measurement at a signal.</li><li><strong>Loop Break</strong> — Specifies a loop opening.</li><li><strong>Open-Loop Input</strong> — Specifies a loop break followed by an input perturbation.</li><li><strong>Open-Loop Output</strong> — Specifies an output measurement followed by a loop break.</li><li><strong>Loop Transfer</strong> — Specifies an output measurement before a loop break followed by an input perturbation.</li><li><strong>Sensitivity</strong> — Specifies an input perturbation followed by an output measurement.</li><li><strong>Complementary Sensitivity</strong> — Specifies an output measurement followed by an input perturbation</li></ul><p>​若想要指定开环分析（屏蔽掉外环反馈），可利用Open-Loop Input&#x2F;Output，可以选择以下组合：1.  <strong>Open-Loop Input+Output Measurement</strong>  2. <strong>Input Perturbation+Output Measurement</strong></p><p>​对选择的信号插入Input Point &#x2F; Output Point</p><ul><li><p>要指定要线性化的模型部分，首先打开线性化选项卡。为此，在Simulink 窗口的Apps 库中，点击Linearization Manager 。</p></li><li><p>要为信号指定分析点，请点击模型中的信号。然后，在“线性化”选项卡上的“插入分析点”库中，选择分析点的类型。</p></li><li><p>将分析的信号配置为Input Perturbation。将输出信号配置为Open-loop Output。开环输出点是在开环后进行的输出测量，它在不改变模型工作点的情况下消除了反馈信号对线性化的影响。要指定要线性化的模型部分，首先打开线性化选项卡。为此，在 Simulink 窗口的 Apps 库中，点击 Linearization Manager 。</p></li></ul><p>​     Model Linearize进入绘制波特图</p><p>实例：</p><p><img src="/2024/03/18/simulinkNote/image-20230619190121382.png" alt="image-20230619190121382"></p><h2 id="Matlab中的C-MEX函数"><a href="#Matlab中的C-MEX函数" class="headerlink" title="Matlab中的C++MEX函数"></a>Matlab中的C++MEX函数</h2><p>​C++与Matlab的混合使用，matlab调用c++的动态链接库或者使用C++MEX函数调用Matlab等可以参看<a href="https://ww2.mathworks.cn/help/matlab/cpp-language.html?s_tid=CRUX_lftnav">官方链接</a>。MEX函数是可以自动加载，可以像任何 MATLAB 函数一样调用的程序，C++MEX其主要依靠<a href="https://ww2.mathworks.cn/help/matlab/matlab-data-array.html">MATLAB Data API</a>与<a href="https://ww2.mathworks.cn/help/matlab/cpp-engine-api.html">MATLAB C++ Engine API</a>，前者提供了C++接口来处理MATLAB数据，后者提供了C++11及串联Matlab的诸多功能处理(如使用<a href="https://ww2.mathworks.cn/help/matlab/apiref/matlab.engine.matlabengine_cpp.html">matlab::engine::MATLABEngine</a>调用matlab函数)。</p><p>​C++MEX函数必须继承基类 <a href="https://ww2.mathworks.cn/help/matlab/apiref/matlab.mex.function.html"><code>matlab::mex::Function</code></a>且名称为 <code>MexFunction</code>的子类，并重写函数调用运算符 <code>operator()</code>；MEX 函数的输入和输出作为<a href="https://ww2.mathworks.cn/help/matlab/apiref/matlab.mex.argumentlist.html"><code>matlab::mex::ArgumentList</code></a> 中的元素进行传递，如下是一个简单的示意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* MyMEXFunction annotation</span><br><span class="hljs-comment"> * c = MyMEXFunction(a,b);</span><br><span class="hljs-comment"> * Adds offset argument a to each element of double array b and</span><br><span class="hljs-comment"> * returns the modified array c.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mex.hpp&quot;</span>   <span class="hljs-comment">// Include this file for the C++ MEX API.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mexAdapter.hpp&quot;</span>  <span class="hljs-comment">// Utility needed for C++ MEX function operator</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> matlab::data;   <br><span class="hljs-keyword">using</span> matlab::mex::ArgumentList; <span class="hljs-comment">// input output data type</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MexFunction</span> : <span class="hljs-keyword">public</span> matlab::mex::Function &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ArgumentList outputs, ArgumentList inputs)</span> </span>&#123;<br>        <span class="hljs-built_in">checkArguments</span>(outputs, inputs);<br>        <span class="hljs-type">const</span> <span class="hljs-type">double</span> offSet = inputs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        TypedArray&lt;<span class="hljs-type">double</span>&gt; doubleArray = std::<span class="hljs-built_in">move</span>(inputs[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : doubleArray) &#123;<br>            elem += offSet;<br>        &#125;<br>        outputs[<span class="hljs-number">0</span>] = doubleArray;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkArguments</span><span class="hljs-params">(ArgumentList outputs, ArgumentList inputs)</span> </span>&#123;<br>        <span class="hljs-comment">// Get pointer to engine</span><br>        std::shared_ptr&lt;matlab::engine::MATLABEngine&gt; matlabPtr = <span class="hljs-built_in">getEngine</span>();<br>        <span class="hljs-comment">// Get array factory: matlab::data::ArrayFactory Create arrays</span><br>        ArrayFactory factory;<br>        <span class="hljs-comment">// Check offset argument: First input must be scalar double</span><br>        <span class="hljs-keyword">if</span> (inputs[<span class="hljs-number">0</span>].<span class="hljs-built_in">getType</span>() != ArrayType::DOUBLE || inputs[<span class="hljs-number">0</span>].<span class="hljs-built_in">getNumberOfElements</span>() != <span class="hljs-number">1</span> || inputs[<span class="hljs-number">1</span>].<span class="hljs-built_in">getType</span>() != ArrayType::DOUBLE)<br>        &#123;<br>            matlabPtr-&gt;<span class="hljs-built_in">feval</span>(<span class="hljs-string">u&quot;error&quot;</span>,<span class="hljs-number">0</span>,<br>                std::<span class="hljs-built_in">vector</span>&lt;Array&gt;(&#123; factory.<span class="hljs-built_in">createScalar</span>(<span class="hljs-string">&quot;Input must be scalar double&quot;</span>) &#125;)); <span class="hljs-comment">// Call the error() using feval()</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​然后使用 <code>mex</code> 命令编译 .cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mex -setup C++  <span class="hljs-comment"># MEX选择c++的编译器</span><br>mex demoMEX.cpp <span class="hljs-comment"># 编译cpp文件生成二进制文件，Windows下为 .mexw64</span><br></code></pre></td></tr></table></figure><p>参考链接<a href="https://ww2.mathworks.cn/help/matlab/matlab_external/c-mex-functions.html">C++ MEX 函数</a>，<a href="https://zhuanlan.zhihu.com/p/511253062">知乎S-function使用</a>，<a href="https://blog.smileland.me/2020/02/12/%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%86%99%E7%AE%80%E5%8D%95S-Function/">2020-02-12-使用C语言写简单S-Function</a></p><h2 id="Simulink中的S-function"><a href="#Simulink中的S-function" class="headerlink" title="Simulink中的S-function"></a>Simulink中的S-function</h2><p>​S-Function属于simulink中的用户自定义模块，是用 MATLAB、C、C++ 或 Fortran  编写的 Simulink 模块的计算机语言描述。使用 mex 实用程序编译为 MEX 文件。S-Function 遵循一般形式，可以适应连续、离散和混合系统。通过遵循一组简单的规则，您可以在 S-Function 中实现算法，并使用  S-Function 模块将其添加到 Simulink 模型。在编写 S-Function 并将其名称放入 S-Function 模块后，您可以使用封装来自定义用户界面（请参阅<a href="https://ww2.mathworks.cn/help/simulink/block-masks.html">Author Block Masks</a>）。</p><p>​S-Function 定义模块在仿真的不同部分（例如初始化、更新、求导、输出和终止）的行为。Level-2 MATLAB S-function是新版simulink引入的升级版，提供了更多的功能与方法。二者均可以在对应模块窗口定义传递参数，各参数以逗号分割。</p><p>​level-1S-Function的通常形式为<code>[sys,x0,str,ts]=f(t,x,u,flag,p1,p2,...)</code>，式中系统根据<code>flag</code>调用不同方法，对应关系如下：</p><table><thead><tr><th>Level-1 Flag</th><th>Level-2 Callback Method</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td><code>setup</code></td><td>定义基本 S-Function 块特征，包括采样时间、连续和离散状态的初始条件以及尺寸数组</td></tr><tr><td>1</td><td><code>mdlDerivatives</code></td><td>计算连续状态变量的导数</td></tr><tr><td>2</td><td><code>mdlUpdate</code></td><td>更新离散状态、采样时间和主要时间步要求</td></tr><tr><td>3</td><td><code>mdlOutputs</code></td><td>计算输出</td></tr><tr><td>4</td><td><code>mdlOutputs</code> 方法更新运行时对象的  <code>NextTimeHit</code> 属性</td><td>以绝对时间计算下一次hit的时间。仅当您在<code>setup</code>方法中指定可变离散时间采样时间时，才使用此例程。</td></tr><tr><td>9</td><td><code>mdlTerminate</code></td><td>执行任何必要的模拟结束任务</td></tr></tbody></table><p>在matlab官方文档中给出了sfundsc2.m转换为sfundsc2_level2.m的代码，可在下表对比：</p><table><thead><tr><th>Code in sfundsc2.m</th><th>Code in Level-2 MATLAB file (sfundsc2_level2.m)</th></tr></thead><tbody><tr><td><code>function [sys,x0,str,ts]= ...  sfundsc2(t,x,u,flag)</code></td><td><code>function sfundsc2(block)  setup(block);</code><br>语法发生更改以接受一个输入参数block，其是 Level-2 MATLAB S-Function 块的运行时间对象。 Level-2 MATLAB S-Function 的主体包含一行调用本地<code>setup</code>函数。</td></tr><tr><td><code>switch flag, case 0, [sys,x0,str,ts] = ...   mdlInitializeSizes;</code></td><td><code>function setup(block)</code><br> 标志位为0 调用<code>setup</code>方法，level-2不使用switch语句，本地<code>setup</code>函数会注册在模拟过程中直接调用回调方法。</td></tr><tr><td><code>case 2,   sys = mdlUpdate(t,x,u); case 3,   sys = mdlOutputs(t,x,u);</code></td><td><code>block.RegBlockMethod(&#39;Outputs&#39; ,@Output); block.RegBlockMethod(&#39;Update&#39;  ,@Update);</code> <br><code>setup</code>函数注册了两个局部函数，分别与标志值2和3关联。</td></tr><tr><td><code>sizes = simsizes; sizes.NumContStates  = 0; sizes.NumDiscStates  = 1; sizes.NumOutputs     = 1; sizes.NumInputs      = 1; sizes.DirFeedthrough = 0; sizes.NumSampleTimes = 1; sys = simsizes(sizes); x0  = 0; str = []; ts  = [.1 0];</code></td><td><code>setup</code>函数还初始化了MATLAB第2级s函数的属性:<br><code>block.NumInputPorts  = 1; block.NumOutputPorts = 1; block.InputPort(1).Dimensions        = 1; block.InputPort(1).DirectFeedthrough = false; block.OutputPort(1).Dimensions       = 1; block.NumDialogPrms     = 0; block.SampleTimes = [0.1 0];</code>由于此 S-Function 具有离散状态，因此 <code>setup</code> 方法会注册 <code>PostPropagationSetup</code> 回调方法来初始化 <code>DWork</code> 向量，并注册 <code>InitializeConditions</code> 回调方法来设置初始状态值。<code>block.RegBlockMethod(&#39;PostPropagationSetup&#39;,... @DoPostPropSetup); block.RegBlockMethod(&#39;InitializeConditions&#39;, ... @InitConditions);</code></td></tr><tr><td><code>sizes.NumDiscStates  = 1;</code></td><td><code>PostPropagationSetup</code>方法初始化存储单个离散状态的<code>DWork</code>向量。<br><code>function DoPostPropSetup(block)   %% Setup Dwork  block.NumDworks = 1;  block.Dwork(1).Name = &#39;x0&#39;;   block.Dwork(1).Dimensions      = 1;  block.Dwork(1).DatatypeID      = 0;  block.Dwork(1).Complexity      = &#39;Real&#39;;  block.Dwork(1).UsedAsDiscState = true; </code></td></tr><tr><td><code>x0  = 0;</code></td><td><code>PostPropagationSetup</code>方法初始化存储单个离散状态的<code>DWork</code>向量。<br><code>function InitConditions(block) %% Initialize Dwork  block.Dwork(1).Data = 0 </code></td></tr><tr><td><code>function sys = ...   mdlUpdate(t,x,u) sys = u;     </code></td><td><code>Update</code>方法计算离散状态的下一个值。<br><code>function Update(block) block.Dwork(1).Data = block.InputPort(1).Data; </code></td></tr><tr><td><code>function sys = ...   mdlOutputs(t,x,u) sys = x;</code></td><td><code>Outputs</code> 方法计算输出。<br><code>function Outputs(block) block.OutputPort(1).Data = block.Dwork(1).Data;</code></td></tr></tbody></table><p>​A Level-2 MATLAB S-function必须包括<code>setup</code>与<code>Outputs</code>两个方法，其余方法及对应的C MEX函数可参考<a href="https://ww2.mathworks.cn/help/simulink/sfg/writing-level-2-matlab-s-functions.html">writing-level-2-matlab-s-functions</a>，官方提供了一个MATLAB S-function模板文件<a href="edit('msfuntmpl_basic.m')">msfuntmpl_basic.m</a>，用来编写自己的程序(也可以使用sfundemos命令来查看内置的所有模板)。<a href="https://ww2.mathworks.cn/help/simulink/sfg/dwork-matlab.html#brd2qpw">DWork</a>向量是 S-Function 要求 Simulink 引擎分配给模型中 S-Function 的每个实例的内存块，通常离散变量需使用它，其需在<code>PostPropagationSetup</code>方法中初始化向量维度与属性，在<code>Start</code> 或 <code>InitializeConditions</code> 方法中设定初值，且可在其余方法中调用。<a href="https://ww2.mathworks.cn/help/simulink/sfg/s-function-concepts.html">S-Function Concepts</a>中介绍了直接馈通对代数环的影响，及采样时间偏移与可变数组的概念。</p><p>​</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msfcn_unit_delay</span><span class="hljs-params">(block)</span></span><br><span class="hljs-comment">% Level-2 MATLAB file S-Function for unit delay demo.</span><br>  setup(block);<br><span class="hljs-comment">%endfunction</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setup</span><span class="hljs-params">(block)</span></span><br>  block.NumDialogPrms  = <span class="hljs-number">1</span>; <span class="hljs-comment">%对话框参数个数</span><br>  block.NumInputPorts  = <span class="hljs-number">1</span>;<br>  block.NumOutputPorts = <span class="hljs-number">1</span>; <span class="hljs-comment">%定义输入输出端口</span><br><br>  block.SetPreCompInpPortInfoToDynamic;<br>  block.SetPreCompOutPortInfoToDynamic;<span class="hljs-comment">%输入端口和输出端口从模型继承编译属性</span><br>  block.InputPort(<span class="hljs-number">1</span>).Dimensions        = <span class="hljs-number">1</span>;<br>  block.InputPort(<span class="hljs-number">1</span>).DirectFeedthrough = <span class="hljs-built_in">false</span>; <span class="hljs-comment">%无直接馈通</span><br>  block.OutputPort(<span class="hljs-number">1</span>).Dimensions       = <span class="hljs-number">1</span>;<br>  <br>  block.SampleTimes = [<span class="hljs-number">0.1</span> <span class="hljs-number">0</span>];<span class="hljs-comment">%[-1 0]表示采用继承的采样时间</span><br>  <span class="hljs-comment">%% Set the block simStateCompliance to default (i.e., same as a built-in block)</span><br>  block.SimStateCompliance = <span class="hljs-string">&#x27;DefaultSimState&#x27;</span>;<br>  <span class="hljs-comment">%% 注册回调方法</span><br>  block.RegBlockMethod(<span class="hljs-string">&#x27;PostPropagationSetup&#x27;</span>, @DoPostPropSetup);<br>  block.RegBlockMethod(<span class="hljs-string">&#x27;InitializeConditions&#x27;</span>, @InitConditions);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Outputs&#x27;</span>, @Output);  <br>  block.RegBlockMethod(<span class="hljs-string">&#x27;Update&#x27;</span>,  @Update);  <br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoPostPropSetup</span><span class="hljs-params">(block)</span></span><br>  <span class="hljs-comment">%% 初始化离散状态变量，不能在setup方法中初始化离散变量</span><br>  block.NumDworks = <span class="hljs-number">1</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).Name = <span class="hljs-string">&#x27;x0&#x27;</span>; <br>  block.Dwork(<span class="hljs-number">1</span>).Dimensions      = <span class="hljs-number">1</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).DatatypeID      = <span class="hljs-number">0</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).Complexity      = <span class="hljs-string">&#x27;Real&#x27;</span>;<br>  block.Dwork(<span class="hljs-number">1</span>).UsedAsDiscState = <span class="hljs-built_in">true</span>;<br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InitConditions</span><span class="hljs-params">(block)</span>%初始化连续或离散<span class="hljs-title">DWork</span>变量的值</span><br>  block.Dwork(<span class="hljs-number">1</span>).Data = block.DialogPrm(<span class="hljs-number">1</span>).Data;<br>  <span class="hljs-comment">% block.ContStates.Data(1) = 1.0; ContStates方法初始化连续变量</span><br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-comment">%% 连续变量必须声明Derivatives方法来设置导数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Derivatives</span><span class="hljs-params">(block)</span></span><br>block.Derivatives.Data(<span class="hljs-number">1</span>) = block.InputPort(<span class="hljs-number">1</span>).Data;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Output</span><span class="hljs-params">(block)</span></span><br>  block.OutputPort(<span class="hljs-number">1</span>).Data = block.Dwork(<span class="hljs-number">1</span>).Data;<br><span class="hljs-comment">%endfunction</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Update</span><span class="hljs-params">(block)</span></span><br>  block.Dwork(<span class="hljs-number">1</span>).Data = block.InputPort(<span class="hljs-number">1</span>).Data;<br><span class="hljs-comment">%endfunction</span><br></code></pre></td></tr></table></figure><h2 id="fuzzyControl工具箱"><a href="#fuzzyControl工具箱" class="headerlink" title="fuzzyControl工具箱"></a>fuzzyControl工具箱</h2><h3 id="模糊推理系统GUI编辑器"><a href="#模糊推理系统GUI编辑器" class="headerlink" title="模糊推理系统GUI编辑器"></a>模糊推理系统GUI编辑器</h3><h4 id="GUI界面"><a href="#GUI界面" class="headerlink" title="GUI界面"></a>GUI界面</h4><p>在matlab命令行输入<code>fuzzy</code>即可进入FIS的GUI。</p><p>界面分为菜单条，模块区，模糊逻辑区与当前变量区。</p><blockquote><p>T-S与Mamdani型的模糊逻辑区与输出量框区存在差异</p></blockquote><p>熟悉编辑FIS输入，输出量的名称与维数。</p><p>Mamdani型的模糊逻辑区：</p><p><img src="/2024/03/18/simulinkNote/Mamdani%E6%A8%A1%E7%B3%8A%E9%80%BB%E8%BE%91%E7%AE%97%E6%B3%95.PNG"></p><p>Sugeno型模糊逻辑区</p><p><img src="/2024/03/18/simulinkNote/T-S%E6%A8%A1%E7%B3%8A%E9%80%BB%E8%BE%91%E7%AE%97%E6%B3%95.PNG"></p><h4 id="隶属函数编辑器"><a href="#隶属函数编辑器" class="headerlink" title="隶属函数编辑器"></a>隶属函数编辑器</h4><p>任意单击输入与输出量模框即可进入MF编辑器。</p><h5 id="Mamdani型MF的编辑"><a href="#Mamdani型MF的编辑" class="headerlink" title="Mamdani型MF的编辑"></a>Mamdani型MF的编辑</h5><ol><li><p>编辑输入&#x2F;出变量的论域(Range)与显示范围(Dispaly Range)。</p></li><li><p>增加覆盖输入&#x2F;出量模糊子集的数目。</p></li><li><p>修改隶属函数曲线：命名，MF类型，非标准函数型MF的修编(拖动拐点与修改参数)</p></li><li><p>修改模糊子集位置：拖动法</p></li></ol><h5 id="Sugeno型MF的编辑"><a href="#Sugeno型MF的编辑" class="headerlink" title="Sugeno型MF的编辑"></a>Sugeno型MF的编辑</h5><p>两种类型推理的输出结论不大相同，前者输出模糊子集，而后者模糊推理输出的是线性函数。</p><p><img src="/2024/03/18/simulinkNote/T-S%E5%9E%8BMF%E8%BE%93%E5%87%BA%E7%95%8C%E9%9D%A2.PNG"></p><h4 id="模糊规则编辑器"><a href="#模糊规则编辑器" class="headerlink" title="模糊规则编辑器"></a>模糊规则编辑器</h4><p>输入量与输出量间的模糊蕴含关系R，用F条件命题对他们进行表述。</p><ol><li><p>Edit与Options的子菜单列表</p><table><thead><tr><th>edit</th><th>Options</th><th></th></tr></thead><tbody><tr><td>Undo</td><td>Language</td><td>Format</td></tr><tr><td>FIS properties…(调出FIS编辑器)</td><td>English</td><td>Verbose(语言型)</td></tr><tr><td>Membership Functions…(调出MF编辑器)</td><td>Deutsch</td><td>Symbolic</td></tr><tr><td>Anfis</td><td>Francais</td><td>Indexed</td></tr></tbody></table></li><li><p>模糊规则的编辑方法</p></li></ol><p>点击Edit-Membership或输入&#x2F;出框图进入隶属函数编辑器，即可通过点击不同的模糊子集与功能键实现输出与输出模糊子集的添加，删除与修改及论域的调整。</p><p>点击Edit-Rules或中间的规则框图即可进入模糊规则编辑器。</p><h4 id="模糊规则观测窗"><a href="#模糊规则观测窗" class="headerlink" title="模糊规则观测窗"></a>模糊规则观测窗</h4><p>点击View-Rules即可进入模糊规则观测窗，可以看到不同输入后的模糊推理与清晰化结果。</p><p>点击上面的surface则可看到模糊规则的三维图</p><h3 id="模糊控制系统的设计与仿真"><a href="#模糊控制系统的设计与仿真" class="headerlink" title="模糊控制系统的设计与仿真"></a>模糊控制系统的设计与仿真</h3><h4 id="FIS与Simulink的连接"><a href="#FIS与Simulink的连接" class="headerlink" title="FIS与Simulink的连接"></a>FIS与Simulink的连接</h4><p> 一般使用<strong>Fuzzy Logic Controller</strong>,右键点击“<strong>Look Under Mask</strong>”即可看到内部结构，使用时需要把使用GUI编辑的FIS结构文件嵌入模块。</p><ol><li>送入工作空间在嵌入</li><li>保存到文件在嵌入</li></ol><h4 id="构建模糊控制系统的仿真模型图"><a href="#构建模糊控制系统的仿真模型图" class="headerlink" title="构建模糊控制系统的仿真模型图"></a>构建模糊控制系统的仿真模型图</h4><ol><li>构建FIS结构文件</li><li>构建仿真模型图</li><li>进行仿真</li></ol><p>熟悉常用模块</p><h4 id="通过仿真对系统进行分析"><a href="#通过仿真对系统进行分析" class="headerlink" title="通过仿真对系统进行分析"></a>通过仿真对系统进行分析</h4><p>有许许多多的模糊模型仿真示例</p><p><img src="/2024/03/18/simulinkNote/MATLAB%E6%A8%A1%E7%B3%8A%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E7%A4%BA%E4%BE%8B.PNG"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    
    <tags>
      
      <tag>simulink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh deploy</title>
    <link href="/2023/06/07/ssh-deploy/"/>
    <url>/2023/06/07/ssh-deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="配置github的ssh密钥"><a href="#配置github的ssh密钥" class="headerlink" title="配置github的ssh密钥"></a>配置github的ssh密钥</h1><p>可见<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys">官方链接</a>，及相关<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/using-ssh-agent-forwarding">ssh配置代理转发</a></p><p>输入 <code>ls -al ~/.ssh</code> 以查看是否存在现有的 SSH 密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~/.ssh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Lists the files <span class="hljs-keyword">in</span> your .ssh directory, <span class="hljs-keyword">if</span> they exist</span><br></code></pre></td></tr></table></figure><p>检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，GitHub 的一个支持的公钥的文件名是以下之一。</p><ul><li>id_rsa.pub</li><li>id_ecdsa.pub</li><li>id_ed25519.pub</li></ul><ol><li>设置用户名与邮箱</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name ‘zhandehuang’</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email ‘it_zdh@163.com’</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成新的ssh密钥(选择不同的加密方式)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br>ssh-keygen -t rsa -C &quot;it_zdh@163.com&quot;<br></code></pre></td></tr></table></figure><p>按照提示输入密钥文件名和密码，直接输入回车选择默认名称与无密码。</p><ol start="3"><li>后台启动ssh代理，并将生成密钥加入ssh-agent</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动ssh代理</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Agent pid 59566</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">id_ed25519变为你生成的本地密钥文件名称，有时候需要重新输入该命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/id_ed25519</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将ssh公钥添加到github仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将生成的公钥文件内容加入到/settings/SSH and GPG keys的SSH keys中</span><br>cat ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><ol start="5"><li>测试连接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hi USERNAME! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">provide shell access.</span></span><br></code></pre></td></tr></table></figure><ol start="6"><li>配置ssh代理转发</li></ol><p>使用你喜欢的文本编辑器打开位于 <code>~/.ssh/config</code> 的文件。 如果此文件不存在，则可以通过在终端中输入 <code>touch ~/.ssh/config</code> 来创建它。在文件中输入以下文本，将 <code>*.github.com</code> 替换为服务器的域名或 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host *.github.com<br>  ForwardAgent yes<br></code></pre></td></tr></table></figure><p>如果不确定是否在使用本地密钥，还可以检查服务器上的 <code>SSH_AUTH_SOCK</code> 变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SSH_AUTH_SOCK</span>&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Print out the SSH_AUTH_SOCK variable</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/tmp/ssh-4hNGMk8AZX/agent.79453</span><br></code></pre></td></tr></table></figure><hr><p>注意事项：</p><ul><li>对于windows下，每次打开git bash都可能需要<code>eval &quot;$(ssh-agent -s)&quot;</code>与<code>ssh-add ~/.ssh/id_ed25519</code>来重新打开agent并加入本地密钥，可利用<code>ssh-add -l</code>检查此时是否打开agent及密钥。</li><li>尽量使用一个git bash进行操作。</li></ul><p>版本: 1.85.1 (user setup)<br>提交: 0ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2<br>日期: 2023-12-13T09:49:37.021Z<br>Electron: 25.9.7<br>ElectronBuildId: 25551756<br>Chromium: 114.0.5735.289<br>Node.js: 18.15.0<br>V8: 11.4.183.29-electron.0<br>OS: Windows_NT x64 10.0.19045</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">scp vscode-<span class="hljs-keyword">server</span>-linux-x64.tar.gz cute@<span class="hljs-number">192.168</span><span class="hljs-number">.43</span><span class="hljs-number">.253</span>:~/.vscode-<span class="hljs-keyword">server</span>/bin<br><br>mv vscode-<span class="hljs-keyword">server</span>-linux-x64 <span class="hljs-number">0</span>ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2<br>rm vscode-<span class="hljs-keyword">server</span>-linux-x64.tar.gz<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2023/06/05/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/06/05/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>测试</p><span id="more"></span><p>&lt;</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br><span class="hljs-variable">$ </span>hexo g   <span class="hljs-comment"># 生成页面</span><br><span class="hljs-variable">$ </span>hexo d   <span class="hljs-comment"># 部署发布</span><br></code></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></p><p><a href="http://www.lzqlearn.com/blog/6560820db005/#2-4-5-%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E6%A0%B7%E5%BC%8F">参考他人博客</a><br><a href="https://zahui.fan/posts/64b52e0d/">typora下载 </a>  <a href="https://rufus.ie/zh/#google_vignette">Rufus启动盘创建</a><br><a href="https://andavid.github.io/2019/01/15/insert-local-image-in-hexo/">使用hexo插入图片</a>可以使用hexo-renderer-marked及hexo-asset-image(node_modules\hexo-asset-image\index.js第58行代码)插件(后者更为简易，高版本或许不适配),但是默认的渲染器并不支持latex公式，因此使用hexo-renderer-marked存在公式渲染问题<a href="https://seekstar.github.io/2021/11/16/hexo%E6%94%AF%E6%8C%81latex%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/">hexo渲染公式</a>。<br><a href="https://qllokirin.github.io/">wh博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BoardBall</title>
    <link href="/2023/05/28/BoardBall/"/>
    <url>/2023/05/28/BoardBall/</url>
    
    <content type="html"><![CDATA[<h1 id="板球系统基本原理"><a href="#板球系统基本原理" class="headerlink" title="板球系统基本原理"></a>板球系统基本原理</h1><p>根据拉格朗日广义方程，结合小角度线性化可得到：</p><p>$\begin{aligned}&amp;\dot{\mathbf{x}}_x&#x3D;A_x\mathbf{x}_x+b_xu_x\ &amp;y_x&#x3D;[1, 0 ,0 ,0] \mathbf{x}_x\ &amp;A_\mathrm{x}&#x3D;\begin{bmatrix}0&amp;1&amp;0&amp;0\0&amp;0&amp;-7.007&amp;0\0&amp;0&amp;0&amp;1\0&amp;0&amp;0&amp;0\end{bmatrix},b_\mathrm{x}&#x3D;\begin{bmatrix}0\0\0\1\end{bmatrix}\end{aligned}$</p><p>式中，$\dot{X}_x&#x3D; [x,v,\alpha,\dot{\alpha}]^T$</p><h1 id="基于BP神经网络的PID控制器"><a href="#基于BP神经网络的PID控制器" class="headerlink" title="基于BP神经网络的PID控制器"></a>基于BP神经网络的PID控制器</h1><h2 id="传统PID控制"><a href="#传统PID控制" class="headerlink" title="传统PID控制"></a>传统PID控制</h2><h1 id="PIDNN（PID神经网络）"><a href="#PIDNN（PID神经网络）" class="headerlink" title="PIDNN（PID神经网络）"></a>PIDNN（PID神经网络）</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>matlab笔记</title>
    <link href="/2023/02/07/matlabNote/"/>
    <url>/2023/02/07/matlabNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Matlab符号计算"><a href="#Matlab符号计算" class="headerlink" title="Matlab符号计算"></a>Matlab符号计算</h1><h2 id="1-符号对象简介"><a href="#1-符号对象简介" class="headerlink" title="1.符号对象简介"></a>1.符号对象简介</h2><h3 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h3><p>符号对象属于MATLAB语言中数据类型之一。符号对象是符号的字符串表示。符号对象主要用于表示：</p><p>符号常量，符号变量，符号函数，各种符号表达式</p><h3 id="符号运算和数值运算的差别"><a href="#符号运算和数值运算的差别" class="headerlink" title="符号运算和数值运算的差别"></a>符号运算和数值运算的差别</h3><ul><li><p>符号运算的结果用分数，幂指数等形式表示。</p></li><li><p>表达式中有一个为符号数据，则整个表达式的计算结果是一个符号数据。</p></li><li><p>数值型表达式计算的结果为数值型数据（包括整型、浮点型）。</p></li></ul><p>可以看出：当采用符号运算时并不直接给出表达式的数值结果，而是给出符号表达。如果要查看符号b所代表的数值，可以使用double()函数。</p><p>符号运算的结果用分数，幂指数等形式表示。</p><h3 id="符号变量和符号表达式的生成"><a href="#符号变量和符号表达式的生成" class="headerlink" title="符号变量和符号表达式的生成"></a>符号变量和符号表达式的生成</h3><p>符号变量是在MATLAB的符号计算中内容可变的符号对象。符号变量与数值变量名称的命名规则相同。可以用命令<code>sym</code>或者<code>syms</code>来建立符号变量，分别用于单个符号变量和多个符号变量的定义.</p><h3 id="“查找”和-“替换”字符变量函数用法"><a href="#“查找”和-“替换”字符变量函数用法" class="headerlink" title="“查找”和 “替换”字符变量函数用法"></a>“查找”和 “替换”字符变量函数用法</h3><ol><li><code>symvar</code>函数用于确定符号表达式中符号变量</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">C = symvar(expr) <span class="hljs-comment">%搜索表达式 expr，查找除 i、j、pi、inf、nan、eps 和公共函数之外的标识符。这些标识符是表达式中变量的名称。symvar 返回字符向量元胞数组 C 中的标识符。如果 symvar 找不到标识符，则 C 是一个空的元胞数组。</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>subs</code>函数用于将符号表达式中的符号变量替换为其他符号变量或数值</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subs(s,old,new)<span class="hljs-comment">%将符号表达式s中所有字符变量old用new替换后将结果返回s</span><br>subs(s,new)    <span class="hljs-comment">%subs(s,new) 将符号表达式s中所有默认的字符变量（一般为一个）用new替换后将结果返回s，默认变量可以通过symvar进行查询。</span><br></code></pre></td></tr></table></figure><h3 id="符号和数值之间的转换"><a href="#符号和数值之间的转换" class="headerlink" title="符号和数值之间的转换"></a>符号和数值之间的转换</h3><ol><li>数值型转换为符号型 <code>sym(x)</code> 或者<code>sym (x,’flag’)</code></li></ol><p>Flag可以是’r’-有理数，’d’-十进制数，’e’-估计误差，’f’-浮点数 </p><ol start="2"><li>字符型转换为数值型<code>double()</code></li></ol><h3 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h3><h3 id="任意精度的计算"><a href="#任意精度的计算" class="headerlink" title="任意精度的计算"></a>任意精度的计算</h3><p>符号计算的优点：不会产生舍入误差，从而可以得到任意精度的数值解<br>符号计算的缺点：需要更多的计算时间和存储空间<br>MATLAB工具箱中3种不同类型的算术运算<br>（1）数值型：浮点数<br>（2）有理数类型：Maple精确符号运算<br>（3）Vpa型：Maple任意精度算术运算</p><h2 id="2-符号表达式的替换与化简"><a href="#2-符号表达式的替换与化简" class="headerlink" title="2.符号表达式的替换与化简"></a>2.符号表达式的替换与化简</h2><h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p><code>expand</code>函数：expand(s)函数能对表达式s进行<strong>因式展开</strong>,常用于多项式、三角函数、指数函数和对数函数。 </p><p><code>factor</code>函数：<strong>因式分解</strong>，factor(s)，s可以是正整数、符号整数、符号表达式或符号矩阵。当s为正整数时，因式分解的结果返回的是s的质数分解式。当s为符号表达式时，结果返回乘积形式。</p><p><code>collect</code>函数：进行符号表达式<strong>同类项合并</strong>。</p><p><code>simplify</code>函数：根据一定规则对符号表达式进行<strong>化简</strong>，它可以完成对指数、对数、三角函数等各种数学表达式的化简。</p><p><code>horner</code>函数：将多项式转换为<strong>嵌套格式</strong>，该格式在多项式求值中可以降低计算时间复杂度。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>subexpr</code>函数：调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[r,sigma] = subexpr(expr)<br><span class="hljs-comment">%使用重复出现的字符串改写表达式expr，重复的字符串用sigma代替，改写后表达式通过r输出</span><br>[r,var] = subexpr(expr,<span class="hljs-string">&#x27;var&#x27;</span>)<br>[r,var] = subexpr(expr,var)<br><span class="hljs-comment">%使用工作空间中已有的字符变量 var或者未有的变量’var’改写表达式expr，重复的字符串用var表示，改写后的表达式通过r输出。</span><br></code></pre></td></tr></table></figure><p><code>subs</code>函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R= subs(s,new)<br><span class="hljs-comment">%使用新的符号变量new代替s表达式中所有默认的变量，即由symvar函数返回变量。</span><br> subs(s,old,new)<br><span class="hljs-comment">%使用新的符号变量new代替s表达式中所有变量old。</span><br></code></pre></td></tr></table></figure><h2 id="3-符号函数图像绘制"><a href="#3-符号函数图像绘制" class="headerlink" title="3.符号函数图像绘制"></a>3.符号函数图像绘制</h2><h3 id="3-1符号函数曲线绘制"><a href="#3-1符号函数曲线绘制" class="headerlink" title="3.1符号函数曲线绘制"></a>3.1符号函数曲线绘制</h3><p>MATLAB中<code>ezplot</code>函数和<code>ezplot3</code>函数分别实现符号函数二维和三维曲线的绘制。(在matlab中推荐使用<code>fplot</code>函数，此函数输入参数指定为<strong>命名或匿名函数的函数句柄</strong>。)</p><blockquote><p>对于<code>ezplot</code>,其输入参数f的选取，</p><p>在使用<strong>函数句柄传递</strong>时，必须使用数组幂、数组乘法和数组除法运算符 (<code>.^, .*, ./</code>)，因为在有字符向量或字符串输入的情况下 <code>ezplot</code> 不改变语法。而在<strong>字符向量与字符串形式传递</strong>函数时，<code>x^2</code> 解释为 <code>x.^2</code>。</p></blockquote><h4 id="显函数绘制"><a href="#显函数绘制" class="headerlink" title="显函数绘制"></a>显函数绘制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(f) <span class="hljs-comment">%绘制函数f在区间[-2pi, 2pi]内的图像；</span><br>ezplot(f, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>])  <span class="hljs-comment">%绘制函数f在指定区间[min, max] 内的图像；</span><br>ezplot(f, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>], fign) <span class="hljs-comment">%在指定的窗口fign中，绘制函数f在指定区间[min, max] 内的图像。</span><br><span class="hljs-comment">%% fplot不支持符号表达式作为输入参数，只可以使用函数句柄传递。在绘制显函数时类似</span><br></code></pre></td></tr></table></figure><h4 id="隐函数绘制"><a href="#隐函数绘制" class="headerlink" title="隐函数绘制"></a>隐函数绘制</h4><p>符号变量隐函数使用时可以使用<code>ezplot</code>,但是不能使用<code>fplot</code>，但是可以使用传入函数句柄的<code>fimplic</code>隐函数绘制函数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(f)  <span class="hljs-comment">%绘制函数f(x,y)=0在区间x和y在[-2pi, 2pi]内的图像；</span><br>ezplot(f, [xmin, xmax, ymin, ymax]) <span class="hljs-comment">%绘制函数在指定区间[xmin, xmax] 、[ymin, ymax]内的图像；</span><br></code></pre></td></tr></table></figure><h4 id="参数方程绘制"><a href="#参数方程绘制" class="headerlink" title="参数方程绘制"></a>参数方程绘制</h4><p><code>ezplot</code>与<code>fplot</code>均可以绘制参数方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(x, y) <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)在区间[0, 2pi]内的曲线；</span><br>ezplot(x, y，[tmin, tmax]) <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)在区间[tmin, tmax]内的曲线；</span><br>fplot(funx,funy,tinterval) <span class="hljs-comment">%将在指定区间绘图。将区间指定为 [tmin tmax] 形式的二元素向量。</span><br></code></pre></td></tr></table></figure><h4 id="三维曲线绘制"><a href="#三维曲线绘制" class="headerlink" title="三维曲线绘制"></a>三维曲线绘制</h4><p>使用<code>ezplot</code>与<code>fplot</code>均可绘制三维曲线，区别也只是后者只能传入命名函数或者匿名函数句柄</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot3(x, y, z), <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)，z=z(t)在区间[0, 2pi]内的图像；</span><br>ezplot3(x, y，z, [tmin, tmax])  <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t), z=z(t) 在区间[tmin, tmax]内的曲线；</span><br>ezplot3(…, ‘animate’) <span class="hljs-comment">%生成空间曲线的动态轨迹。</span><br></code></pre></td></tr></table></figure><h3 id="3-2符号函数曲面绘制"><a href="#3-2符号函数曲面绘制" class="headerlink" title="3.2符号函数曲面绘制"></a>3.2符号函数曲面绘制</h3><p>MATLAB中<code>ezmesh</code>、<code>ezmeshc</code>、<code>ezsurf</code>、<code>ezsurfc</code>函数实现三维网格图，曲面图的绘制，其中后两者会绘<strong>制等值线</strong>图。</p><p>有相应的<code>fmesh</code>，<code>fsurf</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezmesh(f), <span class="hljs-comment">%绘制函数f(x,y)的图像</span><br>ezmesh(f，domain), <span class="hljs-comment">%指定区域绘制函数f(x,y)的图像</span><br>ezmesh(x, y, z), <span class="hljs-comment">%在默认区域绘制三维参数方程图像</span><br>ezmesh(x,y,z，[smin, smax, tmin, tmax])<br>ezmesh(x,y, z, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>]) <span class="hljs-comment">%在指定区域绘制三维参数方程的图像。</span><br><br>ezmeshc(f), 绘制函数f(x,y)在默认区域[<span class="hljs-number">-2</span><span class="hljs-built_in">pi</span>, <span class="hljs-number">2</span><span class="hljs-built_in">pi</span>] 的图像<br>ezmeshc(f，domain), 指定区域绘制函数f(x,y)的图像，domain为<span class="hljs-number">4</span>×<span class="hljs-number">1</span>或<span class="hljs-number">2</span>×<span class="hljs-number">1</span>数组<br>ezmeshc(x, y, z), 在默认区域绘制三维参数方程图像<br>ezmeshc(x, y, z， [smin, smax, tmin, tmax])或ezmeshc(x,y, z, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>] <span class="hljs-comment">%在指定区域绘制三维参数方程的图像。</span><br>ezmeshc(…, n)，<span class="hljs-comment">%指定绘图的网格数，默认为60</span><br>ezmeshc(…, ‘circ’)<span class="hljs-comment">%在以指定区域为中心的原盘上绘制图形</span><br></code></pre></td></tr></table></figure><h3 id="3-3-等值线绘制"><a href="#3-3-等值线绘制" class="headerlink" title="3.3 等值线绘制"></a>3.3 等值线绘制</h3><p>MATLAB中<code>ezcontour</code>和<code>ezcontourf</code>这两个函数分别用于绘制等值线和带有<strong>区域填充</strong>的等值线。以<code>ezcontour</code>函数为例进行介绍。同时也有相应的<code>fcounter</code>函数（调整Fill参数即可实现区域填充）。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezcontour(f), <span class="hljs-comment">%绘制符号二元函数f(x,y)在默认区域内的等值线图像</span><br>ezcontour(f，domain), <span class="hljs-comment">%绘制符号二元函数f(x,y)在指定区域内的等值线图像</span><br>ezcontour(…, n), <span class="hljs-comment">%绘制等值线，并指定等值线数目。</span><br><br>fcontour(@(x,y) <span class="hljs-built_in">erf</span>((y+<span class="hljs-number">2</span>).^<span class="hljs-number">3</span>) - <span class="hljs-built_in">exp</span>(<span class="hljs-number">-0.65</span>*((x<span class="hljs-number">-2</span>).^<span class="hljs-number">2</span>+(y<span class="hljs-number">-2</span>).^<span class="hljs-number">2</span>)),<span class="hljs-string">&#x27;Fill&#x27;</span>,<span class="hljs-string">&#x27;on&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-符号微积分"><a href="#4-符号微积分" class="headerlink" title="4.符号微积分"></a>4.符号微积分</h2><hr><h4 id="4-1符号表达式求极限"><a href="#4-1符号表达式求极限" class="headerlink" title="4.1符号表达式求极限"></a>4.1符号表达式求极限</h4><p>函数<code>limit</code>用于求符号表达式的极限，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">Limit(F, x, a)，<span class="hljs-comment">%当x趋近于a时表达式F的极限。</span><br>Limit(F, a)，<span class="hljs-comment">%当F中的自变量趋近于a时表达式F的极限，自变量由symvar函数确定。</span><br>Limit(F)，<span class="hljs-comment">%当F中的自变量趋近于0时表达式F的极限，自变量由symvar函数确定。</span><br>Limit(F, x, a, ‘right’)，<span class="hljs-comment">%当x从右侧趋近于a时F的极限。</span><br>Limit(F, x, a, ‘left’)，<span class="hljs-comment">%当x从左侧趋近于a时F的极限。</span><br></code></pre></td></tr></table></figure><h4 id="4-2符号微分"><a href="#4-2符号微分" class="headerlink" title="4.2符号微分"></a>4.2符号微分</h4><p>函数<code>diff</code>用于函数求导和求微分，包括一元函数和多元函数。该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">diff(S)，<span class="hljs-comment">%求表达式S的导数，自变量由symvar确定。</span><br>diff(S, ‘v’)，<span class="hljs-comment">%求表达式S对指定变量v的导数，或者diff(S, sym(‘v’))。</span><br>diff(S, n)，<span class="hljs-comment">%求S的n阶导数</span><br>diff(S, ‘v’,n) <span class="hljs-comment">%求S对v的n阶导数，或者diff(S,n,’v’)</span><br></code></pre></td></tr></table></figure><p>MATLAB中<code>Jacobian</code>用于计算jocobian矩阵，该函数调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R=jacobian(f,v)<br><span class="hljs-comment">%如果f是函数向量，v为自变量向量，则计算f的jacobian矩阵，如果f是标量，则计算f的梯度，如果v也是标量，则结果与diff函数相同。</span><br></code></pre></td></tr></table></figure><h4 id="4-3符号积分"><a href="#4-3符号积分" class="headerlink" title="4.3符号积分"></a>4.3符号积分</h4><p>函数<code>int</code>用于求表达式的积分，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R=int(S)，<span class="hljs-comment">%求表达式S的不定积分，自变量通过symvar确定。</span><br>R=int(S,v)，<span class="hljs-comment">%求表达式S对自变量v的不定积分。</span><br>R=int(S, a, b)，<span class="hljs-comment">%求表达式S在区间[a,b]内的定积分。</span><br>R=int(S, v，a, b)，<span class="hljs-comment">%求表达式S在区间[a,b]内的定积分，自变量为v。</span><br></code></pre></td></tr></table></figure><h4 id="4-4级数求和"><a href="#4-4级数求和" class="headerlink" title="4.4级数求和"></a>4.4级数求和</h4><p>函数<code>symsum</code>用于级数求和，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r=symsum(s, v, a, b)，<span class="hljs-comment">%计算变量v从a到b之间s的和。</span><br>r=symsum(s)，<span class="hljs-comment">%自变量通过symvar确定，设其为k，则计算s从0到k-1的和。</span><br>r=symsum(s,v)，<span class="hljs-comment">%计算表达式s从0到v-1的和。</span><br>r=symsum(s, a, b)，<span class="hljs-comment">%计算自变量从a到b之间s的和。</span><br><br>symsum(x^k/<span class="hljs-built_in">factorial</span>(k), k, <span class="hljs-number">0</span>, <span class="hljs-built_in">inf</span>)<br></code></pre></td></tr></table></figure><h4 id="4-5泰勒级数"><a href="#4-5泰勒级数" class="headerlink" title="4.5泰勒级数"></a>4.5泰勒级数</h4><p>函数<code>taylor</code>用于实现taylor级数的计算。该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r=taylor(f)，<span class="hljs-comment">%计算表达式f的泰勒级数，自变量由symvar确定，计算f在0的不超过5阶泰勒级数。</span><br>r=taylor(f, x, a)，<span class="hljs-comment">%计算表达式f在自变量x=a处泰勒级数。</span><br>r=taylor(f, x, ‘order’, n)，<span class="hljs-comment">%计算表达式f在自变量x处n阶泰勒级数。</span><br></code></pre></td></tr></table></figure><h3 id="5-符号方程求解"><a href="#5-符号方程求解" class="headerlink" title="5.符号方程求解"></a>5.符号方程求解</h3><h4 id="5-1代数方程及方程组组求解"><a href="#5-1代数方程及方程组组求解" class="headerlink" title="5.1代数方程及方程组组求解"></a>5.1代数方程及方程组组求解</h4><p>代数方程包括线性方程、非线性方程和超越方程等。在 MATLAB 中函数 <code>solve</code> 用于求解代数方程和方程组，其调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g = solve(eq)，<span class="hljs-comment">%求解方程 eq 的解，对默认自变量求解，输入的参数 eq 可以是符号表达式或字符串；</span><br>g = solve(eq,var)，<span class="hljs-comment">%求解方程 eq 的解，对指定自变量求解。</span><br>g = solve(eq1,eq2,...,eqn)，<span class="hljs-comment">%求由方程 eq1、eq2、…、eqn 等组成的系统，自变量为默认自变量；</span><br>g = solve(eq1,eq2,...,eqn,var1,var2,...,varn)，<span class="hljs-comment">%求由方程eq1、eq2、…、eqn 等组成的系统，自变量为指定的自变量：var1、var2、…、varn。</span><br></code></pre></td></tr></table></figure><h4 id="5-2微分方程及方程组的求解"><a href="#5-2微分方程及方程组的求解" class="headerlink" title="5.2微分方程及方程组的求解"></a>5.2微分方程及方程组的求解</h4><p>微分方程的求解通过函数 <code>dsolve</code> 进行，该函数用于求解常微分方程。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r = dsolve(‘eq1,eq2,...’, ‘cond1,cond2,...’, ‘v’)<br>r = dsolve (<span class="hljs-string">&#x27;eq1&#x27;</span>,<span class="hljs-string">&#x27;eq2&#x27;</span>,...,<span class="hljs-string">&#x27;cond1&#x27;</span>,<span class="hljs-string">&#x27;cond2&#x27;</span>,...,<span class="hljs-string">&#x27;v&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中eq1, eq2等表示待求解的方程，默认自变量t。方程中<strong>用D表示微分</strong>，<strong>D后面的数字表示高阶导数</strong>。Cond1, cond2等表示初始值，通常表示为y(a)&#x3D;b或者Dy(a)&#x3D;b的形式。注意每一个方程应该带上<strong>单引号</strong>，结果放在结构体里。</p><h4 id="5-3复合方程求解"><a href="#5-3复合方程求解" class="headerlink" title="5.3复合方程求解"></a>5.3复合方程求解</h4><p>复合方程通过函数 <code>compose</code> 进行：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">compose(f,g)，<span class="hljs-comment">%返回函数 f(g(y))，其中 f = f(x)，g = g(y)，x 是 f 的默认自变量，y 是 g 的默认自变量；</span><br>compose(f,g,z)，<span class="hljs-comment">%返回函数 f(g(z))，自变量为 z；</span><br>compose(f,g,x,z)，<span class="hljs-comment">%返回函数 f(g(z))，指定 f 的自变量为 x；</span><br>compose(f,g,x,y,z)，<span class="hljs-comment">%返回函数 f(g(z))，f 和 g 的自变量分别指定为 x 和 y。</span><br></code></pre></td></tr></table></figure><h4 id="5-4符号反函数求解"><a href="#5-4符号反函数求解" class="headerlink" title="5.4符号反函数求解"></a>5.4符号反函数求解</h4><p>反方程通过函数 <code>finverse</code> 求得：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g = finverse(f)，<span class="hljs-comment">%在函数 f 的反函数存在的情况下，返回函数 f 的反函数，自变量为默认自变量；</span><br>g = finverse(f,v)，<span class="hljs-comment">%在函数 f 的反函数存在的情况下，返回函数 f 的反函数，自变量为 v。</span><br></code></pre></td></tr></table></figure><h3 id="6-符号积分变换"><a href="#6-符号积分变换" class="headerlink" title="6.符号积分变换"></a>6.符号积分变换</h3><hr><h4 id="6-1符号拉普拉斯变换"><a href="#6-1符号拉普拉斯变换" class="headerlink" title="6.1符号拉普拉斯变换"></a>6.1符号拉普拉斯变换</h4><ol><li><p>傅立叶变换</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = fourier(f)，<span class="hljs-comment">%实现函数f的傅立叶变换，如果 f 的默认自变量为 x，则返回 f 的傅立叶变换结果，默认自变量为w；如果 f 的默认自变量为w，则返回结果的默认自变量为 t。</span><br>F = fourier(f, v)，<span class="hljs-comment">%返回结果为v的函数。</span><br>F = fourier(f, u, v)，<span class="hljs-comment">%f的自变量为u，返回结果为v的函数。</span><br></code></pre></td></tr></table></figure></li><li><p>傅立叶逆变换</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = ifourier(F)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，如果F的默认自变量为w，则返回结果f的默认自变量为x，如果F的自变量为x，则返回结果f的自变量为t。</span><br>f = ifourier(F,u)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，返回结果f为u的函数； </span><br>f = ifourier(F,v,u)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，F的自变量为v，返回结果f为u的函数。</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="6-2符号拉普拉斯变换"><a href="#6-2符号拉普拉斯变换" class="headerlink" title="6.2符号拉普拉斯变换"></a>6.2符号拉普拉斯变换</h4><ol><li>拉普拉斯变换</li></ol><pre><code class="hljs"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">laplace(F)，<span class="hljs-comment">%实现函数F的拉普拉斯变换，如果F的默认自变量为t，返回结果的默认自变量为s如果F的默认自变量为s，则返回结果为t的函数。</span><br>laplace(F, t)，<span class="hljs-comment">%返回函数的自变量为t。</span><br>laplace(F, w, z)，<span class="hljs-comment">%指定F的自变量为w，返回结果为z的函数拉普拉斯逆变换</span><br></code></pre></td></tr></table></figure></code></pre><ol start="2"><li>拉普拉斯逆变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ilaplace(L)，<span class="hljs-comment">%实现函数L的拉普拉斯逆变换，如果L的自变量为s，则返回结果为t的函数；如果L的自变量为t，则返回结果为x的函数。</span><br> F = ilaplace(L, y)，<span class="hljs-comment">%返回结果为y的函数。</span><br> F = ilaplace(L, y, x)，<span class="hljs-comment">%指定L的自变量为y，返回结果为x的函数。</span><br></code></pre></td></tr></table></figure><h4 id="6-3符号Z变换"><a href="#6-3符号Z变换" class="headerlink" title="6.3符号Z变换"></a>6.3符号Z变换</h4><ol><li>Z变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ztrans(f)，<span class="hljs-comment">%如果f的默认自变量为n，则返回结果为z的函数，如果f  为函数z的函数，则返回结果为w的函数。</span><br> F = ztrans(f, w)，<span class="hljs-comment">%返回结果为w的函数。</span><br> F = ztrans(f, k, w)，<span class="hljs-comment">%f的自变量为k，返回结果为w的函数。</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Z 逆变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = iztrans(F)，<span class="hljs-comment">%若F的默认自变量为z，则返回结果为n 的函数；如果F是n 的函数，则返回结果为k的函数。</span><br>f = iztrans(F, k)，<span class="hljs-comment">%指定返回结果为k的函数。</span><br>f = iztrans(F, w, k)，<span class="hljs-comment">%指定F的自变量为w，返回结果为k的函数。</span><br></code></pre></td></tr></table></figure><h3 id="7-符号函数计算器"><a href="#7-符号函数计算器" class="headerlink" title="7.符号函数计算器"></a>7.符号函数计算器</h3><h4 id="7-1单变量符号函数计算器"><a href="#7-1单变量符号函数计算器" class="headerlink" title="7.1单变量符号函数计算器"></a>7.1单变量符号函数计算器</h4><p>在命令窗口中执行<code>funtool</code>即可调出单变量符号函数计算器。单变量符号函数计算器用于对单变量函数进行操作，可以对符号函数进行化简、求导、绘制图形等。</p><p>控制按钮:d</p><p>f&#x2F;dx&#x3D;: 求函数f 的导数。<br>int f:  求函数f的积分。<br>simplify: 对函数f化简<br>num f: 函数f的分子<br>den f: 函数f的分母<br>第2行为函数与常数a之间的操作<br>第3行为函数f与函数g之间的操作<br>第4行功能按钮作用如下：<br>Insert 将函数f加入到函数列表中<br>Cycle 将函数列表中下一个函数代替f值<br>Delete 将f从函数列表中删去<br>Reset 重置计算器                     Help 在线显示帮助<br>Demo 演示                              Close 关闭</p><h4 id="7-2Taylor函数逼近器"><a href="#7-2Taylor函数逼近器" class="headerlink" title="7.2Taylor函数逼近器"></a>7.2Taylor函数逼近器</h4><p>输入<code>taylortool</code>即可进入taylor函数逼近器</p><h1 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h1><p>margin</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear all;clc;<br>ts=<span class="hljs-number">1</span>;  tau=<span class="hljs-number">0.25</span>;L=<span class="hljs-built_in">floor</span>(tau/ts);<br>Gs=tf([<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;inputdelay&#x27;</span>,tau);<br>Gz=c2d(Gs,ts,<span class="hljs-string">&#x27;zoh&#x27;</span>);<br>delay=tf([<span class="hljs-number">1</span>],[<span class="hljs-number">1</span> <span class="hljs-number">0</span>],ts);<br>Gz=Gz*delay;<br>[num,den]=tfdata(Gz,<span class="hljs-string">&#x27;v&#x27;</span>);<br>Gz=filt(num,den,ts);<br>Gz=zpk(Gz);<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">clear</span> <span class="hljs-literal">all</span>;clc;<br><span class="hljs-attribute">G0</span>=tf(<span class="hljs-number">120</span>,conv([<span class="hljs-number">1</span> <span class="hljs-number">0</span>],[<span class="hljs-number">1</span> <span class="hljs-number">4</span>]));<br><span class="hljs-attribute">G</span>=feedback(G0,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">1</span>);bode(G0);grid <span class="hljs-literal">on</span>         %原系统的频域响应<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">2</span>);step(G);grid <span class="hljs-literal">on</span>           %原系统的阶跃响应曲线<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">3</span>);bode(G);grid <span class="hljs-literal">on</span>          %原闭环系统的带宽频率 <br><span class="hljs-attribute">ts</span>=<span class="hljs-number">0</span>.<span class="hljs-number">01</span>;<br><span class="hljs-attribute">Gh</span>=tf(<span class="hljs-number">1</span>,[ts/<span class="hljs-number">2</span> <span class="hljs-number">1</span>]);<br><span class="hljs-attribute">G</span>=G0*Gh;<br><span class="hljs-attribute">Dcs</span>=tf([<span class="hljs-number">0</span>.<span class="hljs-number">2</span> <span class="hljs-number">1</span>],[<span class="hljs-number">0</span>.<span class="hljs-number">02</span> <span class="hljs-number">1</span>]);<br><span class="hljs-attribute">sysc</span>=G*Dcs;<br><span class="hljs-attribute">sys</span>=feedback(sysc,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">Dcz</span>=c2d(Dcs,ts,&#x27;tustin&#x27;);<br><span class="hljs-attribute">Gcz</span>=c2d(G0,ts,&#x27;zoh&#x27;);<br><span class="hljs-attribute">syscz</span>=Dcz*Gcz;<br><span class="hljs-attribute">sysz</span>=feedback(syscz,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">figure</span>(<span class="hljs-number">4</span>);step(sys);hold <span class="hljs-literal">on</span>;step(sysz);grid <span class="hljs-literal">on</span><br><span class="hljs-attribute">figure</span>(<span class="hljs-number">5</span>);bode(syscz);grid <span class="hljs-literal">on</span>        %计算机控制系统的频域响应<br><br></code></pre></td></tr></table></figure><h2 id="sim函数使用"><a href="#sim函数使用" class="headerlink" title="sim函数使用"></a>sim函数使用</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/31/hello-world/"/>
    <url>/2023/01/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
