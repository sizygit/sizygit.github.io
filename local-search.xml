<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>simulink常用工具箱</title>
    <link href="/2023/06/15/simulink%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <url>/2023/06/15/simulink%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="Simulink常用工具箱"><a href="#Simulink常用工具箱" class="headerlink" title="Simulink常用工具箱"></a>Simulink常用工具箱</h1><h2 id="fuzzyControl工具箱"><a href="#fuzzyControl工具箱" class="headerlink" title="fuzzyControl工具箱"></a>fuzzyControl工具箱</h2><h3 id="模糊推理系统GUI编辑器"><a href="#模糊推理系统GUI编辑器" class="headerlink" title="模糊推理系统GUI编辑器"></a>模糊推理系统GUI编辑器</h3><h4 id="GUI界面"><a href="#GUI界面" class="headerlink" title="GUI界面"></a>GUI界面</h4><p>在matlab命令行输入<code>fuzzy</code>即可进入FIS的GUI。</p><p>界面分为菜单条，模块区，模糊逻辑区与当前变量区。</p><blockquote><p>T-S与Mamdani型的模糊逻辑区与输出量框区存在差异</p></blockquote><p>熟悉编辑FIS输入，输出量的名称与维数。</p><p>Mamdani型的模糊逻辑区：</p><p><img src="/simulink%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%B1.assets/Mamdani%E6%A8%A1%E7%B3%8A%E9%80%BB%E8%BE%91%E7%AE%97%E6%B3%95.PNG"></p><p>Sugeno型模糊逻辑区</p><p><img src="/simulink%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%B1.assets/T-S%E6%A8%A1%E7%B3%8A%E9%80%BB%E8%BE%91%E7%AE%97%E6%B3%95.PNG"></p><h4 id="隶属函数编辑器"><a href="#隶属函数编辑器" class="headerlink" title="隶属函数编辑器"></a>隶属函数编辑器</h4><p>任意单击输入与输出量模框即可进入MF编辑器。</p><h5 id="Mamdani型MF的编辑"><a href="#Mamdani型MF的编辑" class="headerlink" title="Mamdani型MF的编辑"></a>Mamdani型MF的编辑</h5><ol><li><p>编辑输入&#x2F;出变量的论域(Range)与显示范围(Dispaly Range)。</p></li><li><p>增加覆盖输入&#x2F;出量模糊子集的数目。</p></li><li><p>修改隶属函数曲线：命名，MF类型，非标准函数型MF的修编(拖动拐点与修改参数)</p></li><li><p>修改模糊子集位置：拖动法</p></li></ol><h5 id="Sugeno型MF的编辑"><a href="#Sugeno型MF的编辑" class="headerlink" title="Sugeno型MF的编辑"></a>Sugeno型MF的编辑</h5><p>两种类型推理的输出结论不大相同，前者输出模糊子集，而后者模糊推理输出的是线性函数。</p><p><img src="/simulink%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%B1.assets/T-S%E5%9E%8BMF%E8%BE%93%E5%87%BA%E7%95%8C%E9%9D%A2.PNG"></p><h4 id="模糊规则编辑器"><a href="#模糊规则编辑器" class="headerlink" title="模糊规则编辑器"></a>模糊规则编辑器</h4><p>输入量与输出量间的模糊蕴含关系R，用F条件命题对他们进行表述。</p><ol><li><p>Edit与Options的子菜单列表</p><table><thead><tr><th>edit</th><th>Options</th><th></th></tr></thead><tbody><tr><td>Undo</td><td>Language</td><td>Format</td></tr><tr><td>FIS properties…(调出FIS编辑器)</td><td>English</td><td>Verbose(语言型)</td></tr><tr><td>Membership Functions…(调出MF编辑器)</td><td>Deutsch</td><td>Symbolic</td></tr><tr><td>Anfis</td><td>Francais</td><td>Indexed</td></tr></tbody></table></li><li><p>模糊规则的编辑方法</p></li></ol><p>点击Edit-Membership或输入&#x2F;出框图进入隶属函数编辑器，即可通过点击不同的模糊子集与功能键实现输出与输出模糊子集的添加，删除与修改及论域的调整。</p><p>点击Edit-Rules或中间的规则框图即可进入模糊规则编辑器。</p><h4 id="模糊规则观测窗"><a href="#模糊规则观测窗" class="headerlink" title="模糊规则观测窗"></a>模糊规则观测窗</h4><p>点击View-Rules即可进入模糊规则观测窗，可以看到不同输入后的模糊推理与清晰化结果。</p><p>点击上面的surface则可看到模糊规则的三维图</p><h3 id="模糊控制系统的设计与仿真"><a href="#模糊控制系统的设计与仿真" class="headerlink" title="模糊控制系统的设计与仿真"></a>模糊控制系统的设计与仿真</h3><h4 id="FIS与Simulink的连接"><a href="#FIS与Simulink的连接" class="headerlink" title="FIS与Simulink的连接"></a>FIS与Simulink的连接</h4><p> 一般使用<strong>Fuzzy Logic Controller</strong>,右键点击“<strong>Look Under Mask</strong>”即可看到内部结构，使用时需要把使用GUI编辑的FIS结构文件嵌入模块。</p><ol><li>送入工作空间在嵌入</li><li>保存到文件在嵌入</li></ol><h4 id="构建模糊控制系统的仿真模型图"><a href="#构建模糊控制系统的仿真模型图" class="headerlink" title="构建模糊控制系统的仿真模型图"></a>构建模糊控制系统的仿真模型图</h4><ol><li>构建FIS结构文件</li><li>构建仿真模型图</li><li>进行仿真</li></ol><p>熟悉常用模块</p><h4 id="通过仿真对系统进行分析"><a href="#通过仿真对系统进行分析" class="headerlink" title="通过仿真对系统进行分析"></a>通过仿真对系统进行分析</h4><p>有许许多多的模糊模型仿真示例</p><p><img src="/simulink%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%B1.assets/MATLAB%E6%A8%A1%E7%B3%8A%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E7%A4%BA%E4%BE%8B.PNG"></p><h2 id="StateFlow工具箱"><a href="#StateFlow工具箱" class="headerlink" title="StateFlow工具箱"></a>StateFlow工具箱</h2><h2 id="Model-Linearizer"><a href="#Model-Linearizer" class="headerlink" title="Model Linearizer"></a><strong>Model Linearizer</strong></h2><p>​使用 Model Linearizer，您可以分析线性化模型的时域和频域响应。您可以比较多个模型的响应并查看稳定裕度和稳定时间等系统特性。</p><p>参考官网链接:<a href="https://ww2-mathworks-cn.translate.goog/help/slcontrol/ug/linearize-simulink-model.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">在模型工作点线性化Simulink 模型</a>,   <a href="https://ww2-mathworks-cn.translate.goog/help/slcontrol/ug/analyze-results-using-linear-analysis-tool-response-plots-1.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">使用模型线性化器响应图分析结果使用模型线性化器响应图分析结果</a></p><p>对选择的信号插入Input Point &#x2F; Output Point</p><ul><li><p>要指定要线性化的模型部分，首先打开线性化选项卡。为此，在Simulink 窗口的Apps 库中，点击Linearization Manager 。</p></li><li><p>要为信号指定分析点，请点击模型中的信号。然后，在“线性化”选项卡上的“插入分析点”库中，选择分析点的类型。</p></li><li><p>将分析的信号配置为Input Perturbation。将输出信号配置为Open-loop Output。开环输出点是在开环后进行的输出测量，它在不改变模型工作点的情况下消除了反馈信号对线性化的影响。要指定要线性化的模型部分，首先打开线性化选项卡。为此，在 Simulink 窗口的 Apps 库中，点击 Linearization Manager 。</p></li></ul><p>Model Linearize进入绘制波特图</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh deploy</title>
    <link href="/2023/06/07/ssh-deploy/"/>
    <url>/2023/06/07/ssh-deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="配置github的ssh密钥"><a href="#配置github的ssh密钥" class="headerlink" title="配置github的ssh密钥"></a>配置github的ssh密钥</h1><p>可见<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys">官方链接</a>，及相关<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/using-ssh-agent-forwarding">ssh配置代理转发</a></p><p>输入 <code>ls -al ~/.ssh</code> 以查看是否存在现有的 SSH 密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~/.ssh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Lists the files <span class="hljs-keyword">in</span> your .ssh directory, <span class="hljs-keyword">if</span> they exist</span><br></code></pre></td></tr></table></figure><p>检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，GitHub 的一个支持的公钥的文件名是以下之一。</p><ul><li>id_rsa.pub</li><li>id_ecdsa.pub</li><li>id_ed25519.pub</li></ul><ol><li>设置用户名与邮箱</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name ‘zhandehuang’</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email ‘it_zdh@163.com’</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成新的ssh密钥(选择不同的加密方式)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br>ssh-keygen -t rsa -C &quot;it_zdh@163.com&quot;<br></code></pre></td></tr></table></figure><p>按照提示输入密钥文件名和密码，直接输入回车选择默认名称与无密码。</p><ol start="3"><li>后台启动ssh代理，并将生成密钥加入ssh-agent</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动ssh代理</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Agent pid 59566</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">id_ed25519变为你生成的本地密钥文件名称，有时候需要重新输入该命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/id_ed25519</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将ssh公钥添加到github仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将生成的公钥文件内容加入到/settings/SSH and GPG keys的SSH keys中</span><br>cat ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><ol start="5"><li>测试连接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hi USERNAME! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">provide shell access.</span></span><br></code></pre></td></tr></table></figure><ol start="6"><li>配置ssh代理转发</li></ol><p>使用你喜欢的文本编辑器打开位于 <code>~/.ssh/config</code> 的文件。 如果此文件不存在，则可以通过在终端中输入 <code>touch ~/.ssh/config</code> 来创建它。在文件中输入以下文本，将 <code>*.github.com</code> 替换为服务器的域名或 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host *.github.com<br>  ForwardAgent yes<br></code></pre></td></tr></table></figure><p>如果不确定是否在使用本地密钥，还可以检查服务器上的 <code>SSH_AUTH_SOCK</code> 变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SSH_AUTH_SOCK</span>&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Print out the SSH_AUTH_SOCK variable</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/tmp/ssh-4hNGMk8AZX/agent.79453</span><br></code></pre></td></tr></table></figure><hr><p>注意事项：</p><ul><li>对于windows下，每次打开git bash都可能需要<code>eval &quot;$(ssh-agent -s)&quot;</code>与<code>ssh-add ~/.ssh/id_ed25519</code>来重新打开agent并加入本地密钥，可利用<code>ssh-add -l</code>检查此时是否打开agent及密钥。</li><li>尽量使用一个git bash进行操作。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2023/06/05/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/06/05/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>测试</p><span id="more"></span><p>&lt;</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br><span class="hljs-variable">$ </span>hexo g   <span class="hljs-comment"># 生成页面</span><br><span class="hljs-variable">$ </span>hexo d   <span class="hljs-comment"># 部署发布</span><br></code></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></p><p><a href="http://www.lzqlearn.com/blog/6560820db005/#2-4-5-%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E6%A0%B7%E5%BC%8F">参考他人博客</a><br><a href="https://zahui.fan/posts/64b52e0d/">typora下载 </a>  <a href="https://rufus.ie/zh/#google_vignette">Rufus启动盘创建</a>   </p><p><a href="https://qllokirin.github.io/">wh博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BoardBall</title>
    <link href="/2023/05/28/BoardBall/"/>
    <url>/2023/05/28/BoardBall/</url>
    
    <content type="html"><![CDATA[<h1 id="基于BP神经网络的PID控制器"><a href="#基于BP神经网络的PID控制器" class="headerlink" title="基于BP神经网络的PID控制器"></a>基于BP神经网络的PID控制器</h1><h2 id="传统PID控制"><a href="#传统PID控制" class="headerlink" title="传统PID控制"></a>传统PID控制</h2><h1 id="PIDNN（PID神经网络）"><a href="#PIDNN（PID神经网络）" class="headerlink" title="PIDNN（PID神经网络）"></a>PIDNN（PID神经网络）</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>matlab笔记</title>
    <link href="/2023/02/07/matlab%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/07/matlab%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Matlab符号计算"><a href="#Matlab符号计算" class="headerlink" title="Matlab符号计算"></a>Matlab符号计算</h1><h2 id="1-符号对象简介"><a href="#1-符号对象简介" class="headerlink" title="1.符号对象简介"></a>1.符号对象简介</h2><h3 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h3><p>符号对象属于MATLAB语言中数据类型之一。符号对象是符号的字符串表示。符号对象主要用于表示：</p><p>符号常量，符号变量，符号函数，各种符号表达式</p><h3 id="符号运算和数值运算的差别"><a href="#符号运算和数值运算的差别" class="headerlink" title="符号运算和数值运算的差别"></a>符号运算和数值运算的差别</h3><ul><li><p>符号运算的结果用分数，幂指数等形式表示。</p></li><li><p>表达式中有一个为符号数据，则整个表达式的计算结果是一个符号数据。</p></li><li><p>数值型表达式计算的结果为数值型数据（包括整型、浮点型）。</p></li></ul><p>可以看出：当采用符号运算时并不直接给出表达式的数值结果，而是给出符号表达。如果要查看符号b所代表的数值，可以使用double()函数。</p><p>符号运算的结果用分数，幂指数等形式表示。</p><h3 id="符号变量和符号表达式的生成"><a href="#符号变量和符号表达式的生成" class="headerlink" title="符号变量和符号表达式的生成"></a>符号变量和符号表达式的生成</h3><p>符号变量是在MATLAB的符号计算中内容可变的符号对象。符号变量与数值变量名称的命名规则相同。可以用命令<code>sym</code>或者<code>syms</code>来建立符号变量，分别用于单个符号变量和多个符号变量的定义.</p><h3 id="“查找”和-“替换”字符变量函数用法"><a href="#“查找”和-“替换”字符变量函数用法" class="headerlink" title="“查找”和 “替换”字符变量函数用法"></a>“查找”和 “替换”字符变量函数用法</h3><ol><li><code>symvar</code>函数用于确定符号表达式中符号变量</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">C = symvar(expr) <span class="hljs-comment">%搜索表达式 expr，查找除 i、j、pi、inf、nan、eps 和公共函数之外的标识符。这些标识符是表达式中变量的名称。symvar 返回字符向量元胞数组 C 中的标识符。如果 symvar 找不到标识符，则 C 是一个空的元胞数组。</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>subs</code>函数用于将符号表达式中的符号变量替换为其他符号变量或数值</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subs(s,old,new)<span class="hljs-comment">%将符号表达式s中所有字符变量old用new替换后将结果返回s</span><br>subs(s,new)    <span class="hljs-comment">%subs(s,new) 将符号表达式s中所有默认的字符变量（一般为一个）用new替换后将结果返回s，默认变量可以通过symvar进行查询。</span><br></code></pre></td></tr></table></figure><h3 id="符号和数值之间的转换"><a href="#符号和数值之间的转换" class="headerlink" title="符号和数值之间的转换"></a>符号和数值之间的转换</h3><ol><li>数值型转换为符号型 <code>sym(x)</code> 或者<code>sym (x,’flag’)</code></li></ol><p>Flag可以是’r’-有理数，’d’-十进制数，’e’-估计误差，’f’-浮点数 </p><ol start="2"><li>字符型转换为数值型<code>double()</code></li></ol><h3 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h3><h3 id="任意精度的计算"><a href="#任意精度的计算" class="headerlink" title="任意精度的计算"></a>任意精度的计算</h3><p>符号计算的优点：不会产生舍入误差，从而可以得到任意精度的数值解<br>符号计算的缺点：需要更多的计算时间和存储空间<br>MATLAB工具箱中3种不同类型的算术运算<br>（1）数值型：浮点数<br>（2）有理数类型：Maple精确符号运算<br>（3）Vpa型：Maple任意精度算术运算</p><h2 id="2-符号表达式的替换与化简"><a href="#2-符号表达式的替换与化简" class="headerlink" title="2.符号表达式的替换与化简"></a>2.符号表达式的替换与化简</h2><h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p><code>expand</code>函数：expand(s)函数能对表达式s进行<strong>因式展开</strong>,常用于多项式、三角函数、指数函数和对数函数。 </p><p><code>factor</code>函数：<strong>因式分解</strong>，factor(s)，s可以是正整数、符号整数、符号表达式或符号矩阵。当s为正整数时，因式分解的结果返回的是s的质数分解式。当s为符号表达式时，结果返回乘积形式。</p><p><code>collect</code>函数：进行符号表达式<strong>同类项合并</strong>。</p><p><code>simplify</code>函数：根据一定规则对符号表达式进行<strong>化简</strong>，它可以完成对指数、对数、三角函数等各种数学表达式的化简。</p><p><code>horner</code>函数：将多项式转换为<strong>嵌套格式</strong>，该格式在多项式求值中可以降低计算时间复杂度。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>subexpr</code>函数：调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[r,sigma] = subexpr(expr)<br><span class="hljs-comment">%使用重复出现的字符串改写表达式expr，重复的字符串用sigma代替，改写后表达式通过r输出</span><br>[r,var] = subexpr(expr,<span class="hljs-string">&#x27;var&#x27;</span>)<br>[r,var] = subexpr(expr,var)<br><span class="hljs-comment">%使用工作空间中已有的字符变量 var或者未有的变量’var’改写表达式expr，重复的字符串用var表示，改写后的表达式通过r输出。</span><br></code></pre></td></tr></table></figure><p><code>subs</code>函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R= subs(s,new)<br><span class="hljs-comment">%使用新的符号变量new代替s表达式中所有默认的变量，即由symvar函数返回变量。</span><br> subs(s,old,new)<br><span class="hljs-comment">%使用新的符号变量new代替s表达式中所有变量old。</span><br></code></pre></td></tr></table></figure><h2 id="3-符号函数图像绘制"><a href="#3-符号函数图像绘制" class="headerlink" title="3.符号函数图像绘制"></a>3.符号函数图像绘制</h2><h3 id="3-1符号函数曲线绘制"><a href="#3-1符号函数曲线绘制" class="headerlink" title="3.1符号函数曲线绘制"></a>3.1符号函数曲线绘制</h3><p>MATLAB中<code>ezplot</code>函数和<code>ezplot3</code>函数分别实现符号函数二维和三维曲线的绘制。(在matlab中推荐使用<code>fplot</code>函数，此函数输入参数指定为<strong>命名或匿名函数的函数句柄</strong>。)</p><blockquote><p>对于<code>ezplot</code>,其输入参数f的选取，</p><p>在使用<strong>函数句柄传递</strong>时，必须使用数组幂、数组乘法和数组除法运算符 (<code>.^, .*, ./</code>)，因为在有字符向量或字符串输入的情况下 <code>ezplot</code> 不改变语法。而在<strong>字符向量与字符串形式传递</strong>函数时，<code>x^2</code> 解释为 <code>x.^2</code>。</p></blockquote><h4 id="显函数绘制"><a href="#显函数绘制" class="headerlink" title="显函数绘制"></a>显函数绘制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(f) <span class="hljs-comment">%绘制函数f在区间[-2pi, 2pi]内的图像；</span><br>ezplot(f, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>])  <span class="hljs-comment">%绘制函数f在指定区间[min, max] 内的图像；</span><br>ezplot(f, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>], fign) <span class="hljs-comment">%在指定的窗口fign中，绘制函数f在指定区间[min, max] 内的图像。</span><br><span class="hljs-comment">%% fplot不支持符号表达式作为输入参数，只可以使用函数句柄传递。在绘制显函数时类似</span><br></code></pre></td></tr></table></figure><h4 id="隐函数绘制"><a href="#隐函数绘制" class="headerlink" title="隐函数绘制"></a>隐函数绘制</h4><p>符号变量隐函数使用时可以使用<code>ezplot</code>,但是不能使用<code>fplot</code>，但是可以使用传入函数句柄的<code>fimplic</code>隐函数绘制函数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(f)  <span class="hljs-comment">%绘制函数f(x,y)=0在区间x和y在[-2pi, 2pi]内的图像；</span><br>ezplot(f, [xmin, xmax, ymin, ymax]) <span class="hljs-comment">%绘制函数在指定区间[xmin, xmax] 、[ymin, ymax]内的图像；</span><br></code></pre></td></tr></table></figure><h4 id="参数方程绘制"><a href="#参数方程绘制" class="headerlink" title="参数方程绘制"></a>参数方程绘制</h4><p><code>ezplot</code>与<code>fplot</code>均可以绘制参数方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot(x, y) <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)在区间[0, 2pi]内的曲线；</span><br>ezplot(x, y，[tmin, tmax]) <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)在区间[tmin, tmax]内的曲线；</span><br>fplot(funx,funy,tinterval) <span class="hljs-comment">%将在指定区间绘图。将区间指定为 [tmin tmax] 形式的二元素向量。</span><br></code></pre></td></tr></table></figure><h4 id="三维曲线绘制"><a href="#三维曲线绘制" class="headerlink" title="三维曲线绘制"></a>三维曲线绘制</h4><p>使用<code>ezplot</code>与<code>fplot</code>均可绘制三维曲线，区别也只是后者只能传入命名函数或者匿名函数句柄</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezplot3(x, y, z), <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t)，z=z(t)在区间[0, 2pi]内的图像；</span><br>ezplot3(x, y，z, [tmin, tmax])  <span class="hljs-comment">%绘制参数方程x=x(t), y=y(t), z=z(t) 在区间[tmin, tmax]内的曲线；</span><br>ezplot3(…, ‘animate’) <span class="hljs-comment">%生成空间曲线的动态轨迹。</span><br></code></pre></td></tr></table></figure><h3 id="3-2符号函数曲面绘制"><a href="#3-2符号函数曲面绘制" class="headerlink" title="3.2符号函数曲面绘制"></a>3.2符号函数曲面绘制</h3><p>MATLAB中<code>ezmesh</code>、<code>ezmeshc</code>、<code>ezsurf</code>、<code>ezsurfc</code>函数实现三维网格图，曲面图的绘制，其中后两者会绘<strong>制等值线</strong>图。</p><p>有相应的<code>fmesh</code>，<code>fsurf</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezmesh(f), <span class="hljs-comment">%绘制函数f(x,y)的图像</span><br>ezmesh(f，domain), <span class="hljs-comment">%指定区域绘制函数f(x,y)的图像</span><br>ezmesh(x, y, z), <span class="hljs-comment">%在默认区域绘制三维参数方程图像</span><br>ezmesh(x,y,z，[smin, smax, tmin, tmax])<br>ezmesh(x,y, z, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>]) <span class="hljs-comment">%在指定区域绘制三维参数方程的图像。</span><br><br>ezmeshc(f), 绘制函数f(x,y)在默认区域[<span class="hljs-number">-2</span><span class="hljs-built_in">pi</span>, <span class="hljs-number">2</span><span class="hljs-built_in">pi</span>] 的图像<br>ezmeshc(f，domain), 指定区域绘制函数f(x,y)的图像，domain为<span class="hljs-number">4</span>×<span class="hljs-number">1</span>或<span class="hljs-number">2</span>×<span class="hljs-number">1</span>数组<br>ezmeshc(x, y, z), 在默认区域绘制三维参数方程图像<br>ezmeshc(x, y, z， [smin, smax, tmin, tmax])或ezmeshc(x,y, z, [<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>] <span class="hljs-comment">%在指定区域绘制三维参数方程的图像。</span><br>ezmeshc(…, n)，<span class="hljs-comment">%指定绘图的网格数，默认为60</span><br>ezmeshc(…, ‘circ’)<span class="hljs-comment">%在以指定区域为中心的原盘上绘制图形</span><br></code></pre></td></tr></table></figure><h3 id="3-3-等值线绘制"><a href="#3-3-等值线绘制" class="headerlink" title="3.3 等值线绘制"></a>3.3 等值线绘制</h3><p>MATLAB中<code>ezcontour</code>和<code>ezcontourf</code>这两个函数分别用于绘制等值线和带有<strong>区域填充</strong>的等值线。以<code>ezcontour</code>函数为例进行介绍。同时也有相应的<code>fcounter</code>函数（调整Fill参数即可实现区域填充）。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ezcontour(f), <span class="hljs-comment">%绘制符号二元函数f(x,y)在默认区域内的等值线图像</span><br>ezcontour(f，domain), <span class="hljs-comment">%绘制符号二元函数f(x,y)在指定区域内的等值线图像</span><br>ezcontour(…, n), <span class="hljs-comment">%绘制等值线，并指定等值线数目。</span><br><br>fcontour(@(x,y) <span class="hljs-built_in">erf</span>((y+<span class="hljs-number">2</span>).^<span class="hljs-number">3</span>) - <span class="hljs-built_in">exp</span>(<span class="hljs-number">-0.65</span>*((x<span class="hljs-number">-2</span>).^<span class="hljs-number">2</span>+(y<span class="hljs-number">-2</span>).^<span class="hljs-number">2</span>)),<span class="hljs-string">&#x27;Fill&#x27;</span>,<span class="hljs-string">&#x27;on&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-符号微积分"><a href="#4-符号微积分" class="headerlink" title="4.符号微积分"></a>4.符号微积分</h2><hr><h4 id="4-1符号表达式求极限"><a href="#4-1符号表达式求极限" class="headerlink" title="4.1符号表达式求极限"></a>4.1符号表达式求极限</h4><p>函数<code>limit</code>用于求符号表达式的极限，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">Limit(F, x, a)，<span class="hljs-comment">%当x趋近于a时表达式F的极限。</span><br>Limit(F, a)，<span class="hljs-comment">%当F中的自变量趋近于a时表达式F的极限，自变量由symvar函数确定。</span><br>Limit(F)，<span class="hljs-comment">%当F中的自变量趋近于0时表达式F的极限，自变量由symvar函数确定。</span><br>Limit(F, x, a, ‘right’)，<span class="hljs-comment">%当x从右侧趋近于a时F的极限。</span><br>Limit(F, x, a, ‘left’)，<span class="hljs-comment">%当x从左侧趋近于a时F的极限。</span><br></code></pre></td></tr></table></figure><h4 id="4-2符号微分"><a href="#4-2符号微分" class="headerlink" title="4.2符号微分"></a>4.2符号微分</h4><p>函数<code>diff</code>用于函数求导和求微分，包括一元函数和多元函数。该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">diff(S)，<span class="hljs-comment">%求表达式S的导数，自变量由symvar确定。</span><br>diff(S, ‘v’)，<span class="hljs-comment">%求表达式S对指定变量v的导数，或者diff(S, sym(‘v’))。</span><br>diff(S, n)，<span class="hljs-comment">%求S的n阶导数</span><br>diff(S, ‘v’,n) <span class="hljs-comment">%求S对v的n阶导数，或者diff(S,n,’v’)</span><br></code></pre></td></tr></table></figure><p>MATLAB中<code>Jacobian</code>用于计算jocobian矩阵，该函数调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R=jacobian(f,v)<br><span class="hljs-comment">%如果f是函数向量，v为自变量向量，则计算f的jacobian矩阵，如果f是标量，则计算f的梯度，如果v也是标量，则结果与diff函数相同。</span><br></code></pre></td></tr></table></figure><h4 id="4-3符号积分"><a href="#4-3符号积分" class="headerlink" title="4.3符号积分"></a>4.3符号积分</h4><p>函数<code>int</code>用于求表达式的积分，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">R=int(S)，<span class="hljs-comment">%求表达式S的不定积分，自变量通过symvar确定。</span><br>R=int(S,v)，<span class="hljs-comment">%求表达式S对自变量v的不定积分。</span><br>R=int(S, a, b)，<span class="hljs-comment">%求表达式S在区间[a,b]内的定积分。</span><br>R=int(S, v，a, b)，<span class="hljs-comment">%求表达式S在区间[a,b]内的定积分，自变量为v。</span><br></code></pre></td></tr></table></figure><h4 id="4-4级数求和"><a href="#4-4级数求和" class="headerlink" title="4.4级数求和"></a>4.4级数求和</h4><p>函数<code>symsum</code>用于级数求和，该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r=symsum(s, v, a, b)，<span class="hljs-comment">%计算变量v从a到b之间s的和。</span><br>r=symsum(s)，<span class="hljs-comment">%自变量通过symvar确定，设其为k，则计算s从0到k-1的和。</span><br>r=symsum(s,v)，<span class="hljs-comment">%计算表达式s从0到v-1的和。</span><br>r=symsum(s, a, b)，<span class="hljs-comment">%计算自变量从a到b之间s的和。</span><br><br>symsum(x^k/<span class="hljs-built_in">factorial</span>(k), k, <span class="hljs-number">0</span>, <span class="hljs-built_in">inf</span>)<br></code></pre></td></tr></table></figure><h4 id="4-5泰勒级数"><a href="#4-5泰勒级数" class="headerlink" title="4.5泰勒级数"></a>4.5泰勒级数</h4><p>函数<code>taylor</code>用于实现taylor级数的计算。该函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r=taylor(f)，<span class="hljs-comment">%计算表达式f的泰勒级数，自变量由symvar确定，计算f在0的不超过5阶泰勒级数。</span><br>r=taylor(f, x, a)，<span class="hljs-comment">%计算表达式f在自变量x=a处泰勒级数。</span><br>r=taylor(f, x, ‘order’, n)，<span class="hljs-comment">%计算表达式f在自变量x处n阶泰勒级数。</span><br></code></pre></td></tr></table></figure><h3 id="5-符号方程求解"><a href="#5-符号方程求解" class="headerlink" title="5.符号方程求解"></a>5.符号方程求解</h3><h4 id="5-1代数方程及方程组组求解"><a href="#5-1代数方程及方程组组求解" class="headerlink" title="5.1代数方程及方程组组求解"></a>5.1代数方程及方程组组求解</h4><p>代数方程包括线性方程、非线性方程和超越方程等。在 MATLAB 中函数 <code>solve</code> 用于求解代数方程和方程组，其调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g = solve(eq)，<span class="hljs-comment">%求解方程 eq 的解，对默认自变量求解，输入的参数 eq 可以是符号表达式或字符串；</span><br>g = solve(eq,var)，<span class="hljs-comment">%求解方程 eq 的解，对指定自变量求解。</span><br>g = solve(eq1,eq2,...,eqn)，<span class="hljs-comment">%求由方程 eq1、eq2、…、eqn 等组成的系统，自变量为默认自变量；</span><br>g = solve(eq1,eq2,...,eqn,var1,var2,...,varn)，<span class="hljs-comment">%求由方程eq1、eq2、…、eqn 等组成的系统，自变量为指定的自变量：var1、var2、…、varn。</span><br></code></pre></td></tr></table></figure><h4 id="5-2微分方程及方程组的求解"><a href="#5-2微分方程及方程组的求解" class="headerlink" title="5.2微分方程及方程组的求解"></a>5.2微分方程及方程组的求解</h4><p>微分方程的求解通过函数 <code>dsolve</code> 进行，该函数用于求解常微分方程。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">r = dsolve(‘eq1,eq2,...’, ‘cond1,cond2,...’, ‘v’)<br>r = dsolve (<span class="hljs-string">&#x27;eq1&#x27;</span>,<span class="hljs-string">&#x27;eq2&#x27;</span>,...,<span class="hljs-string">&#x27;cond1&#x27;</span>,<span class="hljs-string">&#x27;cond2&#x27;</span>,...,<span class="hljs-string">&#x27;v&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中eq1, eq2等表示待求解的方程，默认自变量t。方程中<strong>用D表示微分</strong>，<strong>D后面的数字表示高阶导数</strong>。Cond1, cond2等表示初始值，通常表示为y(a)&#x3D;b或者Dy(a)&#x3D;b的形式。注意每一个方程应该带上<strong>单引号</strong>，结果放在结构体里。</p><h4 id="5-3复合方程求解"><a href="#5-3复合方程求解" class="headerlink" title="5.3复合方程求解"></a>5.3复合方程求解</h4><p>复合方程通过函数 <code>compose</code> 进行：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">compose(f,g)，<span class="hljs-comment">%返回函数 f(g(y))，其中 f = f(x)，g = g(y)，x 是 f 的默认自变量，y 是 g 的默认自变量；</span><br>compose(f,g,z)，<span class="hljs-comment">%返回函数 f(g(z))，自变量为 z；</span><br>compose(f,g,x,z)，<span class="hljs-comment">%返回函数 f(g(z))，指定 f 的自变量为 x；</span><br>compose(f,g,x,y,z)，<span class="hljs-comment">%返回函数 f(g(z))，f 和 g 的自变量分别指定为 x 和 y。</span><br></code></pre></td></tr></table></figure><h4 id="5-4符号反函数求解"><a href="#5-4符号反函数求解" class="headerlink" title="5.4符号反函数求解"></a>5.4符号反函数求解</h4><p>反方程通过函数 <code>finverse</code> 求得：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g = finverse(f)，<span class="hljs-comment">%在函数 f 的反函数存在的情况下，返回函数 f 的反函数，自变量为默认自变量；</span><br>g = finverse(f,v)，<span class="hljs-comment">%在函数 f 的反函数存在的情况下，返回函数 f 的反函数，自变量为 v。</span><br></code></pre></td></tr></table></figure><h3 id="6-符号积分变换"><a href="#6-符号积分变换" class="headerlink" title="6.符号积分变换"></a>6.符号积分变换</h3><hr><h4 id="6-1符号拉普拉斯变换"><a href="#6-1符号拉普拉斯变换" class="headerlink" title="6.1符号拉普拉斯变换"></a>6.1符号拉普拉斯变换</h4><ol><li><p>傅立叶变换</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = fourier(f)，<span class="hljs-comment">%实现函数f的傅立叶变换，如果 f 的默认自变量为 x，则返回 f 的傅立叶变换结果，默认自变量为w；如果 f 的默认自变量为w，则返回结果的默认自变量为 t。</span><br>F = fourier(f, v)，<span class="hljs-comment">%返回结果为v的函数。</span><br>F = fourier(f, u, v)，<span class="hljs-comment">%f的自变量为u，返回结果为v的函数。</span><br></code></pre></td></tr></table></figure></li><li><p>傅立叶逆变换</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = ifourier(F)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，如果F的默认自变量为w，则返回结果f的默认自变量为x，如果F的自变量为x，则返回结果f的自变量为t。</span><br>f = ifourier(F,u)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，返回结果f为u的函数； </span><br>f = ifourier(F,v,u)，<span class="hljs-comment">%实现函数F的傅立叶逆变换，F的自变量为v，返回结果f为u的函数。</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="6-2符号拉普拉斯变换"><a href="#6-2符号拉普拉斯变换" class="headerlink" title="6.2符号拉普拉斯变换"></a>6.2符号拉普拉斯变换</h4><ol><li>拉普拉斯变换</li></ol><pre><code class="hljs"><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">laplace(F)，<span class="hljs-comment">%实现函数F的拉普拉斯变换，如果F的默认自变量为t，返回结果的默认自变量为s如果F的默认自变量为s，则返回结果为t的函数。</span><br>laplace(F, t)，<span class="hljs-comment">%返回函数的自变量为t。</span><br>laplace(F, w, z)，<span class="hljs-comment">%指定F的自变量为w，返回结果为z的函数拉普拉斯逆变换</span><br></code></pre></td></tr></table></figure></code></pre><ol start="2"><li>拉普拉斯逆变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ilaplace(L)，<span class="hljs-comment">%实现函数L的拉普拉斯逆变换，如果L的自变量为s，则返回结果为t的函数；如果L的自变量为t，则返回结果为x的函数。</span><br> F = ilaplace(L, y)，<span class="hljs-comment">%返回结果为y的函数。</span><br> F = ilaplace(L, y, x)，<span class="hljs-comment">%指定L的自变量为y，返回结果为x的函数。</span><br></code></pre></td></tr></table></figure><h4 id="6-3符号Z变换"><a href="#6-3符号Z变换" class="headerlink" title="6.3符号Z变换"></a>6.3符号Z变换</h4><ol><li>Z变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ztrans(f)，<span class="hljs-comment">%如果f的默认自变量为n，则返回结果为z的函数，如果f  为函数z的函数，则返回结果为w的函数。</span><br> F = ztrans(f, w)，<span class="hljs-comment">%返回结果为w的函数。</span><br> F = ztrans(f, k, w)，<span class="hljs-comment">%f的自变量为k，返回结果为w的函数。</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Z 逆变换</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = iztrans(F)，<span class="hljs-comment">%若F的默认自变量为z，则返回结果为n 的函数；如果F是n 的函数，则返回结果为k的函数。</span><br>f = iztrans(F, k)，<span class="hljs-comment">%指定返回结果为k的函数。</span><br>f = iztrans(F, w, k)，<span class="hljs-comment">%指定F的自变量为w，返回结果为k的函数。</span><br></code></pre></td></tr></table></figure><h3 id="7-符号函数计算器"><a href="#7-符号函数计算器" class="headerlink" title="7.符号函数计算器"></a>7.符号函数计算器</h3><h4 id="7-1单变量符号函数计算器"><a href="#7-1单变量符号函数计算器" class="headerlink" title="7.1单变量符号函数计算器"></a>7.1单变量符号函数计算器</h4><p>在命令窗口中执行<code>funtool</code>即可调出单变量符号函数计算器。单变量符号函数计算器用于对单变量函数进行操作，可以对符号函数进行化简、求导、绘制图形等。</p><p>控制按钮:d</p><p>f&#x2F;dx&#x3D;: 求函数f 的导数。<br>int f:  求函数f的积分。<br>simplify: 对函数f化简<br>num f: 函数f的分子<br>den f: 函数f的分母<br>第2行为函数与常数a之间的操作<br>第3行为函数f与函数g之间的操作<br>第4行功能按钮作用如下：<br>Insert 将函数f加入到函数列表中<br>Cycle 将函数列表中下一个函数代替f值<br>Delete 将f从函数列表中删去<br>Reset 重置计算器                     Help 在线显示帮助<br>Demo 演示                              Close 关闭</p><h4 id="7-2Taylor函数逼近器"><a href="#7-2Taylor函数逼近器" class="headerlink" title="7.2Taylor函数逼近器"></a>7.2Taylor函数逼近器</h4><p>输入<code>taylortool</code>即可进入taylor函数逼近器</p><h1 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h1><p>margin</p>]]></content>
    
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/31/hello-world/"/>
    <url>/2023/01/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
